<html>
<body>
<table border="1">
<tr>
<td>name</td><td>value</td><td>description</td>
</tr>
<tr>
<td><a name="hadoop.hdfs.configuration.version">hadoop.hdfs.configuration.version</a></td><td>1</td><td>version of this configuration file</td>
</tr>
<tr>
<td><a name="dfs.namenode.logging.level">dfs.namenode.logging.level</a></td><td>info</td><td>The logging level for dfs namenode. Other values are "dir"(trac
e namespace mutations), "block"(trace block under/over replications and block
creations/deletions), or "all".</td>
</tr>
<tr>
<td><a name="dfs.namenode.secondary.http-address">dfs.namenode.secondary.http-address</a></td><td>0.0.0.0:50090</td><td>
    The secondary namenode http server address and port.
    If the port is 0 then the server will start on a free port.
  </td>
</tr>
<tr>
<td><a name="dfs.datanode.address">dfs.datanode.address</a></td><td>0.0.0.0:50010</td><td>
    The address where the datanode server will listen to.
    If the port is 0 then the server will start on a free port.
  </td>
</tr>
<tr>
<td><a name="dfs.datanode.http.address">dfs.datanode.http.address</a></td><td>0.0.0.0:50075</td><td>
    The datanode http server address and port.
    If the port is 0 then the server will start on a free port.
  </td>
</tr>
<tr>
<td><a name="dfs.datanode.ipc.address">dfs.datanode.ipc.address</a></td><td>0.0.0.0:50020</td><td>
    The datanode ipc server address and port.
    If the port is 0 then the server will start on a free port.
  </td>
</tr>
<tr>
<td><a name="dfs.datanode.handler.count">dfs.datanode.handler.count</a></td><td>3</td><td>The number of server threads for the datanode.</td>
</tr>
<tr>
<td><a name="dfs.namenode.http-address">dfs.namenode.http-address</a></td><td>0.0.0.0:50070</td><td>
    The address and the base port where the dfs namenode web ui will listen on.
    If the port is 0 then the server will start on a free port.
  </td>
</tr>
<tr>
<td><a name="dfs.https.enable">dfs.https.enable</a></td><td>false</td><td>Decide if HTTPS(SSL) is supported on HDFS
  </td>
</tr>
<tr>
<td><a name="dfs.client.https.need-auth">dfs.client.https.need-auth</a></td><td>false</td><td>Whether SSL client certificate authentication is required
  </td>
</tr>
<tr>
<td><a name="dfs.https.server.keystore.resource">dfs.https.server.keystore.resource</a></td><td>ssl-server.xml</td><td>Resource file from which ssl server keystore
  information will be extracted
  </td>
</tr>
<tr>
<td><a name="dfs.client.https.keystore.resource">dfs.client.https.keystore.resource</a></td><td>ssl-client.xml</td><td>Resource file from which ssl client keystore
  information will be extracted
  </td>
</tr>
<tr>
<td><a name="dfs.datanode.https.address">dfs.datanode.https.address</a></td><td>0.0.0.0:50475</td><td></td>
</tr>
<tr>
<td><a name="dfs.namenode.https-address">dfs.namenode.https-address</a></td><td>0.0.0.0:50470</td><td></td>
</tr>
<tr>
<td><a name="dfs.datanode.dns.interface">dfs.datanode.dns.interface</a></td><td>default</td><td>The name of the Network Interface from which a data node should 
  report its IP address.
  </td>
</tr>
<tr>
<td><a name="dfs.datanode.dns.nameserver">dfs.datanode.dns.nameserver</a></td><td>default</td><td>The host name or IP address of the name server (DNS)
  which a DataNode should use to determine the host name used by the
  NameNode for communication and display purposes.
  </td>
</tr>
<tr>
<td><a name="dfs.namenode.backup.address">dfs.namenode.backup.address</a></td><td>0.0.0.0:50100</td><td>
    The backup node server address and port.
    If the port is 0 then the server will start on a free port.
  </td>
</tr>
<tr>
<td><a name="dfs.namenode.backup.http-address">dfs.namenode.backup.http-address</a></td><td>0.0.0.0:50105</td><td>
    The backup node http server address and port.
    If the port is 0 then the server will start on a free port.
  </td>
</tr>
<tr>
<td><a name="dfs.namenode.replication.considerLoad">dfs.namenode.replication.considerLoad</a></td><td>true</td><td>Decide if chooseTarget considers the target's load or not
  </td>
</tr>
<tr>
<td><a name="dfs.default.chunk.view.size">dfs.default.chunk.view.size</a></td><td>32768</td><td>The number of bytes to view for a file on the browser.
  </td>
</tr>
<tr>
<td><a name="dfs.datanode.du.reserved">dfs.datanode.du.reserved</a></td><td>0</td><td>Reserved space in bytes per volume. Always leave this much space free for non dfs use.
  </td>
</tr>
<tr>
<td><a name="dfs.namenode.name.dir">dfs.namenode.name.dir</a></td><td>file://${hadoop.tmp.dir}/dfs/name</td><td>Determines where on the local filesystem the DFS name node
      should store the name table(fsimage).  If this is a comma-delimited list
      of directories then the name table is replicated in all of the
      directories, for redundancy. </td>
</tr>
<tr>
<td><a name="dfs.namenode.edits.dir">dfs.namenode.edits.dir</a></td><td>${dfs.namenode.name.dir}</td><td>Determines where on the local filesystem the DFS name node
      should store the transaction (edits) file. If this is a comma-delimited list
      of directories then the transaction file is replicated in all of the 
      directories, for redundancy. Default value is same as dfs.name.dir
  </td>
</tr>
<tr>
<td><a name="dfs.web.ugi">dfs.web.ugi</a></td><td>webuser,webgroup</td><td>The user account used by the web interface.
    Syntax: USERNAME,GROUP1,GROUP2, ...
  </td>
</tr>
<tr>
<td><a name="dfs.permissions.enabled">dfs.permissions.enabled</a></td><td>true</td><td>
    If "true", enable permission checking in HDFS.
    If "false", permission checking is turned off,
    but all other behavior is unchanged.
    Switching from one parameter value to the other does not change the mode,
    owner or group of files or directories.
  </td>
</tr>
<tr>
<td><a name="dfs.permissions.superusergroup">dfs.permissions.superusergroup</a></td><td>supergroup</td><td>The name of the group of super-users.</td>
</tr>
<tr>
<td><a name="dfs.block.access.token.enable">dfs.block.access.token.enable</a></td><td>false</td><td>
    If "true", access tokens are used as capabilities for accessing datanodes.
    If "false", no access tokens are checked on accessing datanodes.
  </td>
</tr>
<tr>
<td><a name="dfs.block.access.key.update.interval">dfs.block.access.key.update.interval</a></td><td>600</td><td>
    Interval in minutes at which namenode updates its access keys.
  </td>
</tr>
<tr>
<td><a name="dfs.block.access.token.lifetime">dfs.block.access.token.lifetime</a></td><td>600</td><td>The lifetime of access tokens in minutes.</td>
</tr>
<tr>
<td><a name="dfs.datanode.data.dir">dfs.datanode.data.dir</a></td><td>file://${hadoop.tmp.dir}/dfs/data</td><td>Determines where on the local filesystem an DFS data node
  should store its blocks.  If this is a comma-delimited
  list of directories, then data will be stored in all named
  directories, typically on different devices.
  Directories that do not exist are ignored.
  </td>
</tr>
<tr>
<td><a name="dfs.datanode.data.dir.perm">dfs.datanode.data.dir.perm</a></td><td>700</td><td>Permissions for the directories on on the local filesystem where
  the DFS data node store its blocks. The permissions can either be octal or
  symbolic.</td>
</tr>
<tr>
<td><a name="dfs.replication">dfs.replication</a></td><td>3</td><td>Default block replication. 
  The actual number of replications can be specified when the file is created.
  The default is used if replication is not specified in create time.
  </td>
</tr>
<tr>
<td><a name="dfs.replication.max">dfs.replication.max</a></td><td>512</td><td>Maximal block replication. 
  </td>
</tr>
<tr>
<td><a name="dfs.namenode.replication.min">dfs.namenode.replication.min</a></td><td>1</td><td>Minimal block replication. 
  </td>
</tr>
<tr>
<td><a name="dfs.blocksize">dfs.blocksize</a></td><td>67108864</td><td>The default block size for new files.</td>
</tr>
<tr>
<td><a name="dfs.client.block.write.retries">dfs.client.block.write.retries</a></td><td>3</td><td>The number of retries for writing blocks to the data nodes, 
  before we signal failure to the application.
  </td>
</tr>
<tr>
<td><a name="dfs.blockreport.intervalMsec">dfs.blockreport.intervalMsec</a></td><td>21600000</td><td>Determines block reporting interval in milliseconds.</td>
</tr>
<tr>
<td><a name="dfs.blockreport.initialDelay">dfs.blockreport.initialDelay</a></td><td>0</td><td>Delay for first block report in seconds.</td>
</tr>
<tr>
<td><a name="dfs.datanode.directoryscan.interval">dfs.datanode.directoryscan.interval</a></td><td>21600</td><td>Interval in seconds for Datanode to scan data directories and
  reconcile the difference between blocks in memory and on the disk.
  </td>
</tr>
<tr>
<td><a name="dfs.datanode.directoryscan.threads">dfs.datanode.directoryscan.threads</a></td><td>1</td><td>How many threads should the threadpool used to compile reports
  for volumes in parallel have.
  </td>
</tr>
<tr>
<td><a name="dfs.heartbeat.interval">dfs.heartbeat.interval</a></td><td>3</td><td>Determines datanode heartbeat interval in seconds.</td>
</tr>
<tr>
<td><a name="dfs.namenode.handler.count">dfs.namenode.handler.count</a></td><td>10</td><td>The number of server threads for the namenode.</td>
</tr>
<tr>
<td><a name="dfs.namenode.safemode.threshold-pct">dfs.namenode.safemode.threshold-pct</a></td><td>0.999f</td><td>
    Specifies the percentage of blocks that should satisfy 
    the minimal replication requirement defined by dfs.namenode.replication.min.
    Values less than or equal to 0 mean not to wait for any particular
    percentage of blocks before exiting safemode.
    Values greater than 1 will make safe mode permanent.
  </td>
</tr>
<tr>
<td><a name="dfs.namenode.safemode.min.datanodes">dfs.namenode.safemode.min.datanodes</a></td><td>0</td><td>
    Specifies the number of datanodes that must be considered alive
    before the name node exits safemode.
    Values less than or equal to 0 mean not to take the number of live
    datanodes into account when deciding whether to remain in safe mode
    during startup.
    Values greater than the number of datanodes in the cluster
    will make safe mode permanent.
  </td>
</tr>
<tr>
<td><a name="dfs.namenode.safemode.extension">dfs.namenode.safemode.extension</a></td><td>30000</td><td>
    Determines extension of safe mode in milliseconds 
    after the threshold level is reached.
  </td>
</tr>
<tr>
<td><a name="dfs.datanode.balance.bandwidthPerSec">dfs.datanode.balance.bandwidthPerSec</a></td><td>1048576</td><td>
        Specifies the maximum amount of bandwidth that each datanode
        can utilize for the balancing purpose in term of
        the number of bytes per second.
  </td>
</tr>
<tr>
<td><a name="dfs.hosts">dfs.hosts</a></td><td></td><td>Names a file that contains a list of hosts that are
  permitted to connect to the namenode. The full pathname of the file
  must be specified.  If the value is empty, all hosts are
  permitted.</td>
</tr>
<tr>
<td><a name="dfs.hosts.exclude">dfs.hosts.exclude</a></td><td></td><td>Names a file that contains a list of hosts that are
  not permitted to connect to the namenode.  The full pathname of the
  file must be specified.  If the value is empty, no hosts are
  excluded.</td>
</tr>
<tr>
<td><a name="dfs.namenode.max.objects">dfs.namenode.max.objects</a></td><td>0</td><td>The maximum number of files, directories and blocks
  dfs supports. A value of zero indicates no limit to the number
  of objects that dfs supports.
  </td>
</tr>
<tr>
<td><a name="dfs.namenode.decommission.interval">dfs.namenode.decommission.interval</a></td><td>30</td><td>Namenode periodicity in seconds to check if decommission is 
  complete.</td>
</tr>
<tr>
<td><a name="dfs.namenode.decommission.nodes.per.interval">dfs.namenode.decommission.nodes.per.interval</a></td><td>5</td><td>The number of nodes namenode checks if decommission is complete
  in each dfs.namenode.decommission.interval.</td>
</tr>
<tr>
<td><a name="dfs.namenode.replication.interval">dfs.namenode.replication.interval</a></td><td>3</td><td>The periodicity in seconds with which the namenode computes 
  repliaction work for datanodes. </td>
</tr>
<tr>
<td><a name="dfs.namenode.accesstime.precision">dfs.namenode.accesstime.precision</a></td><td>3600000</td><td>The access time for HDFS file is precise upto this value. 
               The default value is 1 hour. Setting a value of 0 disables
               access times for HDFS.
  </td>
</tr>
<tr>
<td><a name="dfs.datanode.plugins">dfs.datanode.plugins</a></td><td></td><td>Comma-separated list of datanode plug-ins to be activated.
  </td>
</tr>
<tr>
<td><a name="dfs.namenode.plugins">dfs.namenode.plugins</a></td><td></td><td>Comma-separated list of namenode plug-ins to be activated.
  </td>
</tr>
<tr>
<td><a name="dfs.stream-buffer-size">dfs.stream-buffer-size</a></td><td>4096</td><td>The size of buffer to stream files.
  The size of this buffer should probably be a multiple of hardware
  page size (4096 on Intel x86), and it determines how much data is
  buffered during read and write operations.</td>
</tr>
<tr>
<td><a name="dfs.bytes-per-checksum">dfs.bytes-per-checksum</a></td><td>512</td><td>The number of bytes per checksum.  Must not be larger than
  dfs.stream-buffer-size</td>
</tr>
<tr>
<td><a name="dfs.client-write-packet-size">dfs.client-write-packet-size</a></td><td>65536</td><td>Packet size for clients to write</td>
</tr>
<tr>
<td><a name="dfs.namenode.checkpoint.dir">dfs.namenode.checkpoint.dir</a></td><td>file://${hadoop.tmp.dir}/dfs/namesecondary</td><td>Determines where on the local filesystem the DFS secondary
      name node should store the temporary images to merge.
      If this is a comma-delimited list of directories then the image is
      replicated in all of the directories for redundancy.
  </td>
</tr>
<tr>
<td><a name="dfs.namenode.checkpoint.edits.dir">dfs.namenode.checkpoint.edits.dir</a></td><td>${dfs.namenode.checkpoint.dir}</td><td>Determines where on the local filesystem the DFS secondary
      name node should store the temporary edits to merge.
      If this is a comma-delimited list of directoires then teh edits is
      replicated in all of the directoires for redundancy.
      Default value is same as dfs.namenode.checkpoint.dir
  </td>
</tr>
<tr>
<td><a name="dfs.namenode.checkpoint.period">dfs.namenode.checkpoint.period</a></td><td>3600</td><td>The number of seconds between two periodic checkpoints.
  </td>
</tr>
<tr>
<td><a name="dfs.namenode.checkpoint.size">dfs.namenode.checkpoint.size</a></td><td>67108864</td><td>The size of the current edit log (in bytes) that triggers
       a periodic checkpoint even if the dfs.namenode.checkpoint.period hasn't expired.
  </td>
</tr>
<tr>
<td><a name="dfs.namenode.delegation.key.update-interval">dfs.namenode.delegation.key.update-interval</a></td><td>86400000</td><td>The update interval for master key for delegation tokens 
       in the namenode in milliseconds.
  </td>
</tr>
<tr>
<td><a name="dfs.namenode.delegation.token.max-lifetime">dfs.namenode.delegation.token.max-lifetime</a></td><td>604800000</td><td>The maximum lifetime in milliseconds for which a delegation 
      token is valid.
  </td>
</tr>
<tr>
<td><a name="dfs.namenode.delegation.token.renew-interval">dfs.namenode.delegation.token.renew-interval</a></td><td>86400000</td><td>The renewal interval for delegation token in milliseconds.
  </td>
</tr>
<tr>
<td><a name="dfs.datanode.failed.volumes.tolerated">dfs.datanode.failed.volumes.tolerated</a></td><td>0</td><td>The number of volumes that are allowed to
  fail before a datanode stops offering service. By default
  any volume failure will cause a datanode to shutdown.
  </td>
</tr>
<tr>
<td><a name="dfs.image.compress">dfs.image.compress</a></td><td>false</td><td>Should the dfs image be compressed?
  </td>
</tr>
<tr>
<td><a name="dfs.image.compression.codec">dfs.image.compression.codec</a></td><td>org.apache.hadoop.io.compress.DefaultCodec</td><td>If the dfs image is compressed, how should they be compressed?
               This has to be a codec defined in io.compression.codecs.
  </td>
</tr>
<tr>
<td><a name="dfs.image.transfer.bandwidthPerSec">dfs.image.transfer.bandwidthPerSec</a></td><td>0</td><td>
        Specifies the maximum amount of bandwidth that can be utilized for image
        transfer in term of the number of bytes per second.
        A default value of 0 indicates that throttling is disabled. 
  </td>
</tr>
<tr>
<td><a name="dfs.namenode.support.allow.format">dfs.namenode.support.allow.format</a></td><td>true</td><td>Does HDFS namenode allow itself to be formatted?
               You may consider setting this to false for any production
               cluster, to avoid any possibility of formatting a running DFS.
  </td>
</tr>
<tr>
<td><a name="dfs.datanode.max.transfer.threads">dfs.datanode.max.transfer.threads</a></td><td>4096</td><td>
        Specifies the maximum number of threads to use for transferring data
        in and out of the DN.
  </td>
</tr>
</table>
</body>
</html>
