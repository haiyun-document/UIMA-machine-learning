<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.9">
<meta name="Forrest-skin-name" content="pelt">
<title>MapReduce Tutorial</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="images/favicon.ico">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<!--+
    |breadtrail
    +-->
<div class="breadtrail">
<a href="http://www.apache.org/">Apache</a> &gt; <a href="http://hadoop.apache.org/">Hadoop</a> &gt; <a href="http://hadoop.apache.org/core/">Core</a><script src="skin/breadcrumbs.js" language="JavaScript" type="text/javascript"></script>
</div>
<!--+
    |header
    +-->
<div class="header">
<!--+
    |start group logo
    +-->
<div class="grouplogo">
<a href="http://hadoop.apache.org/"><img class="logoImage" alt="Hadoop" src="images/hadoop-logo.jpg" title="Apache Hadoop"></a>
</div>
<!--+
    |end group logo
    +-->
<!--+
    |start Project Logo
    +-->
<div class="projectlogo">
<a href="http://hadoop.apache.org/core/"><img class="logoImage" alt="Hadoop" src="images/mapreduce-logo.jpg" title="Scalable Computing Platform"></a>
</div>
<!--+
    |end Project Logo
    +-->
<!--+
    |start Search
    +-->
<div class="searchbox">
<form action="http://www.google.com/search" method="get" class="roundtopsmall">
<input value="hadoop.apache.org" name="sitesearch" type="hidden"><input onFocus="getBlank (this, 'Search the site with google');" size="25" name="q" id="query" type="text" value="Search the site with google">&nbsp; 
                    <input name="Search" value="Search" type="submit">
</form>
</div>
<!--+
    |end search
    +-->
<!--+
    |start Tabs
    +-->
<ul id="tabs">
<li>
<a class="unselected" href="http://hadoop.apache.org/mapreduce/">Project</a>
</li>
<li>
<a class="unselected" href="http://wiki.apache.org/hadoop/MapReduce">Wiki</a>
</li>
<li class="current">
<a class="selected" href="index.html">MapReduce 0.22 Documentation</a>
</li>
</ul>
<!--+
    |end Tabs
    +-->
</div>
</div>
<div id="main">
<div id="publishedStrip">
<!--+
    |start Subtabs
    +-->
<div id="level2tabs"></div>
<!--+
    |end Endtabs
    +-->
<script type="text/javascript"><!--
document.write("Last Published: " + document.lastModified);
//  --></script>
</div>
<!--+
    |breadtrail
    +-->
<div class="breadtrail">

             &nbsp;
           </div>
<!--+
    |start Menu, mainarea
    +-->
<!--+
    |start Menu
    +-->
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Getting Started</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html">Overview</a>
</div>
<div class="menupage">
<div class="menupagetitle">MapReduce Tutorial</div>
</div>
<div class="menuitem">
<a href="streaming.html">Hadoop Streaming</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.2', 'skin/')" id="menu_1.2Title" class="menutitle">Guides</div>
<div id="menu_1.2" class="menuitemgroup">
<div class="menuitem">
<a href="distcp.html">DistCp</a>
</div>
<div class="menuitem">
<a href="vaidya.html">Vaidya</a>
</div>
<div class="menuitem">
<a href="hadoop_archives.html">Hadoop Archives</a>
</div>
<div class="menuitem">
<a href="gridmix.html">Gridmix</a>
</div>
<div class="menuitem">
<a href="rumen.html">Rumen</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.3', 'skin/')" id="menu_1.3Title" class="menutitle">Schedulers</div>
<div id="menu_1.3" class="menuitemgroup">
<div class="menuitem">
<a href="capacity_scheduler.html">Capacity Scheduler</a>
</div>
<div class="menuitem">
<a href="fair_scheduler.html">Fair Scheduler</a>
</div>
<div class="menuitem">
<a href="dynamic_scheduler.html">Dynamic Priority Scheduler</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.4', 'skin/')" id="menu_1.4Title" class="menutitle">Miscellaneous</div>
<div id="menu_1.4" class="menuitemgroup">
<div class="menuitem">
<a href="api/index.html">API Docs</a>
</div>
<div class="menuitem">
<a href="jdiff/changes.html">API Changes</a>
</div>
<div class="menuitem">
<a href="http://wiki.apache.org/hadoop/MapReduce">Wiki</a>
</div>
<div class="menuitem">
<a href="http://wiki.apache.org/hadoop/MapReduce/FAQ">FAQ</a>
</div>
<div class="menuitem">
<a href="releasenotes.html">Release Notes</a>
</div>
<div class="menuitem">
<a href="changes.html">Change Log</a>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<!--+
  |alternative credits
  +-->
<div id="credit2"></div>
</div>
<!--+
    |end Menu
    +-->
<!--+
    |start content
    +-->
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="mapred_tutorial.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>MapReduce Tutorial</h1>
<div id="front-matter">
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Purpose">Purpose</a>
</li>
<li>
<a href="#Prerequisites">Prerequisites</a>
</li>
<li>
<a href="#Overview">Overview</a>
</li>
<li>
<a href="#Inputs+and+Outputs">Inputs and Outputs</a>
</li>
<li>
<a href="#Example%3A+WordCount+v1.0">Example: WordCount v1.0</a>
<ul class="minitoc">
<li>
<a href="#Source+Code">Source Code</a>
</li>
<li>
<a href="#Usage">Usage</a>
</li>
<li>
<a href="#Bundling+a+data+payload+with+your+application">Bundling a data payload with your application</a>
</li>
<li>
<a href="#Walk-through">Walk-through</a>
</li>
</ul>
</li>
<li>
<a href="#MapReduce+-+User+Interfaces">MapReduce - User Interfaces</a>
<ul class="minitoc">
<li>
<a href="#Payload">Payload</a>
<ul class="minitoc">
<li>
<a href="#Mapper">Mapper</a>
</li>
<li>
<a href="#Reducer">Reducer</a>
</li>
<li>
<a href="#Partitioner">Partitioner</a>
</li>
<li>
<a href="#Reporting+Progress">Reporting Progress</a>
</li>
</ul>
</li>
<li>
<a href="#Job+Configuration">Job Configuration</a>
</li>
<li>
<a href="#Task+Execution+%26+Environment">Task Execution &amp; Environment</a>
<ul class="minitoc">
<li>
<a href="#Configuring+Memory+Requirements+For+A+Job">Configuring Memory Requirements For A Job</a>
</li>
<li>
<a href="#Map+Parameters">Map Parameters</a>
</li>
<li>
<a href="#Shuffle%2FReduce+Parameters">Shuffle/Reduce Parameters</a>
</li>
<li>
<a href="#Directory+Structure"> Directory Structure </a>
</li>
<li>
<a href="#Task+JVM+Reuse">Task JVM Reuse</a>
</li>
<li>
<a href="#Configured+Parameters">Configured Parameters</a>
</li>
<li>
<a href="#Task+Logs">Task Logs</a>
</li>
<li>
<a href="#Distributing+Libraries">Distributing Libraries</a>
</li>
<li>
<a href="#Job+Credentials">Job Credentials</a>
</li>
</ul>
</li>
<li>
<a href="#Job+Submission+and+Monitoring">Job Submission and Monitoring</a>
<ul class="minitoc">
<li>
<a href="#Job+Control">Job Control</a>
</li>
<li>
<a href="#Job+Authorization">Job Authorization</a>
</li>
</ul>
</li>
<li>
<a href="#Job+Input">Job Input</a>
<ul class="minitoc">
<li>
<a href="#InputSplit">InputSplit</a>
</li>
<li>
<a href="#RecordReader">RecordReader</a>
</li>
</ul>
</li>
<li>
<a href="#Job+Output">Job Output</a>
<ul class="minitoc">
<li>
<a href="#Lazy+Output+Creation">Lazy Output Creation</a>
</li>
<li>
<a href="#OutputCommitter">OutputCommitter</a>
</li>
<li>
<a href="#Task+Side-Effect+Files">Task Side-Effect Files</a>
</li>
<li>
<a href="#RecordWriter">RecordWriter</a>
</li>
</ul>
</li>
<li>
<a href="#Other+Useful+Features">Other Useful Features</a>
<ul class="minitoc">
<li>
<a href="#Submitting+Jobs+to+Queues">Submitting Jobs to Queues</a>
</li>
<li>
<a href="#Counters">Counters</a>
</li>
<li>
<a href="#DistributedCache">DistributedCache</a>
</li>
<li>
<a href="#Tool">Tool</a>
</li>
<li>
<a href="#IsolationRunner">IsolationRunner</a>
</li>
<li>
<a href="#Profiling">Profiling</a>
</li>
<li>
<a href="#Debugging">Debugging</a>
</li>
<li>
<a href="#JobControl">JobControl</a>
</li>
<li>
<a href="#Data+Compression">Data Compression</a>
</li>
<li>
<a href="#Skipping+Bad+Records">Skipping Bad Records</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#Example%3A+WordCount+v2.0">Example: WordCount v2.0</a>
<ul class="minitoc">
<li>
<a href="#Source+Code-N1128C">Source Code</a>
</li>
<li>
<a href="#Sample+Runs">Sample Runs</a>
</li>
<li>
<a href="#Highlights">Highlights</a>
</li>
</ul>
</li>
</ul>
</div>
</div>

    
<a name="Purpose"></a>
<h2 class="h3">Purpose</h2>
<div class="section">
<p>This document comprehensively describes all user-facing facets of the 
      Hadoop MapReduce framework and serves as a tutorial.
      </p>
</div>
    
    
<a name="Prerequisites"></a>
<h2 class="h3">Prerequisites</h2>
<div class="section">
<p>Make sure Hadoop is installed, configured and running. See these guides:
      </p>
<ul>
        
<li>
          
<a href="http://hadoop.apache.org/common/docs/current/single_node_setup.html">Single Node Setup</a> for first-time users.
        </li>
        
<li>
          
<a href="http://hadoop.apache.org/common/docs/current/cluster_setup.html">Cluster Setup</a> for large, distributed clusters.
        </li>
      
</ul>
</div>
    
    
<a name="Overview"></a>
<h2 class="h3">Overview</h2>
<div class="section">
<p>Hadoop MapReduce is a software framework for easily writing 
      applications which process vast amounts of data (multi-terabyte data-sets) 
      in-parallel on large clusters (thousands of nodes) of commodity 
      hardware in a reliable, fault-tolerant manner.</p>
<p>A MapReduce <em>job</em> usually splits the input data-set into 
      independent chunks which are processed by the <em>map tasks</em> in a
      completely parallel manner. The framework sorts the outputs of the maps, 
      which are then input to the <em>reduce tasks</em>. Typically both the 
      input and the output of the job are stored in a file-system. The framework 
      takes care of scheduling tasks, monitoring them and re-executes the failed
      tasks.</p>
<p>Typically the compute nodes and the storage nodes are the same, that is, 
      the MapReduce framework and the 
      <a href="http://hadoop.apache.org/hdfs/docs/current/index.html">Hadoop
        Distributed File System</a> (HDFS) 
      are running on the same set of nodes. This configuration
      allows the framework to effectively schedule tasks on the nodes where data 
      is already present, resulting in very high aggregate bandwidth across the 
      cluster.</p>
<p>The MapReduce framework consists of a single master 
      <span class="codefrag">JobTracker</span> and one slave <span class="codefrag">TaskTracker</span> per 
      cluster-node. The master is responsible for scheduling the jobs' component 
      tasks on the slaves, monitoring them and re-executing the failed tasks. The 
      slaves execute the tasks as directed by the master.</p>
<p>Minimally, applications specify the input/output locations and supply
      <em>map</em> and <em>reduce</em> functions via implementations of
      appropriate interfaces and/or abstract-classes. These, and other job 
      parameters, comprise the <em>job configuration</em>. The Hadoop 
      <em>job client</em> then submits the job (jar/executable etc.) and 
      configuration to the <span class="codefrag">JobTracker</span> which then assumes the 
      responsibility of distributing the software/configuration to the slaves, 
      scheduling tasks and monitoring them, providing status and diagnostic 
      information to the job-client.</p>
<p>Although the Hadoop framework is implemented in Java<sup>TM</sup>, 
      MapReduce applications need not be written in Java.</p>
<ul>
        
<li>
          
<a href="api/org/apache/hadoop/streaming/package-summary.html">
          Hadoop Streaming</a> is a utility which allows users to create and run 
          jobs with any executables (e.g. shell utilities) as the mapper and/or 
          the reducer.
        </li>
        
<li>
          
<a href="api/org/apache/hadoop/mapred/pipes/package-summary.html">
          Hadoop Pipes</a> is a <a href="http://www.swig.org/">SWIG</a>-
          compatible <em>C++ API</em> to implement MapReduce applications (non 
          JNI<sup>TM</sup> based).
        </li>
      
</ul>
</div>
    
    
<a name="Inputs+and+Outputs"></a>
<h2 class="h3">Inputs and Outputs</h2>
<div class="section">
<p>The MapReduce framework operates exclusively on 
      <span class="codefrag">&lt;key, value&gt;</span> pairs, that is, the framework views the 
      input to the job as a set of <span class="codefrag">&lt;key, value&gt;</span> pairs and 
      produces a set of <span class="codefrag">&lt;key, value&gt;</span> pairs as the output of 
      the job, conceivably of different types.</p>
<p>The <span class="codefrag">key</span> and <span class="codefrag">value</span> classes have to be 
        serializable by the framework. Several serialization systems exists; the
        default serialization mechanism requires keys and values to implement
        the
      <a href="api/org/apache/hadoop/io/Writable.html">Writable</a> interface.
      Additionally, the <span class="codefrag">key</span> classes must facilitate sorting by the
      framework; a straightforward means to do so is for them to implement the
      <a href="api/org/apache/hadoop/io/WritableComparable.html">
        WritableComparable</a> interface.
      </p>
<p>Input and Output types of a MapReduce job:</p>
<p>
        (input) <span class="codefrag">&lt;k1, v1&gt;</span> 
        -&gt; 
        <strong>map</strong> 
        -&gt; 
        <span class="codefrag">&lt;k2, v2&gt;</span> 
        -&gt; 
        <strong>combine*</strong> 
        -&gt; 
        <span class="codefrag">&lt;k2, v2&gt;</span> 
        -&gt; 
        <strong>reduce</strong> 
        -&gt; 
        <span class="codefrag">&lt;k3, v3&gt;</span> (output)
      </p>
<p>Note that the combine phase may run zero or more times in this
        process.</p>
</div>
    
    
<a name="Example%3A+WordCount+v1.0"></a>
<h2 class="h3">Example: WordCount v1.0</h2>
<div class="section">
<p>Before we jump into the details, lets walk through an example MapReduce 
      application to get a flavour for how they work.</p>
<p>
<span class="codefrag">WordCount</span> is a simple application that counts the number of
      occurences of each word in a given input set.</p>
<p>This example works with a 
      pseudo-distributed (<a href="http://hadoop.apache.org/common/docs/current/single_node_setup.html">Single Node Setup</a>) 
     or fully-distributed (<a href="http://hadoop.apache.org/common/docs/current/cluster_setup.html">Cluster Setup</a>) 
      Hadoop installation.</p>
<a name="Source+Code"></a>
<h3 class="h4">Source Code</h3>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
          
<tr>
            
<th colspan="1" rowspan="1"></th>
            <th colspan="1" rowspan="1">WordCount.java</th>
          
</tr>

<tr>
<td colspan="1" rowspan="1">1.</td><td colspan="1" rowspan="1"><span class="codefrag">package&nbsp;org.myorg;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">2.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">3.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;java.io.IOException;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">4.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;java.util.*;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">5.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">6.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;org.apache.hadoop.fs.Path;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">7.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;org.apache.hadoop.conf.*;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">8.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;org.apache.hadoop.io.*;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">9.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;org.apache.hadoop.mapreduce.*;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">10.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;org.apache.hadoop.mapreduce.lib.input.*;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">11.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;org.apache.hadoop.mapreduce.lib.output.*;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">12.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;org.apache.hadoop.util.*;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">13.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">14.</td><td colspan="1" rowspan="1"><span class="codefrag">public&nbsp;class&nbsp;WordCount&nbsp;extends&nbsp;Configured&nbsp;implements&nbsp;Tool&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">15.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">16.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;class&nbsp;Map
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">17.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extends&nbsp;Mapper&lt;LongWritable,&nbsp;Text,&nbsp;Text,&nbsp;IntWritable&gt;&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">18.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;static&nbsp;IntWritable&nbsp;one&nbsp;=&nbsp;new&nbsp;IntWritable(1);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">19.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Text&nbsp;word&nbsp;=&nbsp;new&nbsp;Text();
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">20.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">21.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;map(LongWritable&nbsp;key,&nbsp;Text&nbsp;value,&nbsp;Context&nbsp;context)
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">22.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;IOException,&nbsp;InterruptedException&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">23.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;line&nbsp;=&nbsp;value.toString();
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">24.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer&nbsp;tokenizer&nbsp;=&nbsp;new&nbsp;StringTokenizer(line);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">25.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(tokenizer.hasMoreTokens())&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">26.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;word.set(tokenizer.nextToken());
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">27.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context.write(word,&nbsp;one);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">28.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">29.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">30.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">31.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">32.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;class&nbsp;Reduce
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">33.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extends&nbsp;Reducer&lt;Text,&nbsp;IntWritable,&nbsp;Text,&nbsp;IntWritable&gt;&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">34.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;reduce(Text&nbsp;key,&nbsp;Iterable&lt;IntWritable&gt;&nbsp;values,
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">35.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Context&nbsp;context)&nbsp;throws&nbsp;IOException,&nbsp;InterruptedException&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">36.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">37.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;sum&nbsp;=&nbsp;0;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">38.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(IntWritable&nbsp;val&nbsp;:&nbsp;values)&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">39.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;val.get();
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">40.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">41.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context.write(key,&nbsp;new&nbsp;IntWritable(sum));
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">42.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">43.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">44.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">45.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;run(String&nbsp;[]&nbsp;args)&nbsp;throws&nbsp;Exception&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">46.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Job&nbsp;job&nbsp;=&nbsp;new&nbsp;Job(getConf());
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">47.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.setJarByClass(WordCount.class);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">48.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.setJobName("wordcount");
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">49.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">50.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.setOutputKeyClass(Text.class);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">51.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.setOutputValueClass(IntWritable.class);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">52.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">53.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.setMapperClass(Map.class);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">54.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.setCombinerClass(Reduce.class);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">55.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.setReducerClass(Reduce.class);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">56.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">57.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.setInputFormatClass(TextInputFormat.class);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">58.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.setOutputFormatClass(TextOutputFormat.class);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">59.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">60.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileInputFormat.setInputPaths(job,&nbsp;new&nbsp;Path(args[0]));
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">61.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileOutputFormat.setOutputPath(job,&nbsp;new&nbsp;Path(args[1]));
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">62.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">63.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;success&nbsp;=&nbsp;job.waitForCompletion(true);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">64.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;success&nbsp;?&nbsp;0&nbsp;:&nbsp;1;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">65.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">66.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">67.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;Exception&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">68.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ret&nbsp;=&nbsp;ToolRunner.run(new&nbsp;WordCount(),&nbsp;args);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">69.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(ret);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">70.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">71.</td><td colspan="1" rowspan="1"><span class="codefrag">}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">72.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>
        
</table>
<a name="Usage"></a>
<h3 class="h4">Usage</h3>
<p>Assuming <span class="codefrag">HADOOP_HOME</span> is the root of the installation and 
        <span class="codefrag">HADOOP_VERSION</span> is the Hadoop version installed, compile 
        <span class="codefrag">WordCount.java</span> and create a jar:</p>
<p>
          
<span class="codefrag">$ mkdir wordcount_classes</span>
<br>
          
<span class="codefrag">
            $ javac -classpath
            ${HADOOP_HOME}/hadoop-core-${HADOOP_VERSION}.jar:${HADOOP_HOME}/hadoop-mapred-${HADOOP_VERSION}.jar:${HADOOP_HOME}/hadoop-hdfs-${HADOOP_VERSION}.jar
              -d wordcount_classes WordCount.java
          </span>
<br>
          
<span class="codefrag">$ jar -cvf /user/joe/wordcount.jar -C wordcount_classes/ .</span> 
        
</p>
<p>Assuming that:</p>
<ul>
          
<li>
            
<span class="codefrag">/user/joe/wordcount/input</span>  - input directory in HDFS
          </li>
          
<li>
            
<span class="codefrag">/user/joe/wordcount/output</span> - output directory in HDFS
          </li>
        
</ul>
<p>Sample text-files as input:</p>
<p>
          
<span class="codefrag">$ bin/hadoop fs -ls /user/joe/wordcount/input/</span>
<br>
          
<span class="codefrag">/user/joe/wordcount/input/file01</span>
<br>
          
<span class="codefrag">/user/joe/wordcount/input/file02</span>
<br>
          
<br>
          
<span class="codefrag">$ bin/hadoop fs -cat /user/joe/wordcount/input/file01</span>
<br>
          
<span class="codefrag">Hello World Bye World</span>
<br>
          
<br>
          
<span class="codefrag">$ bin/hadoop fs -cat /user/joe/wordcount/input/file02</span>
<br>
          
<span class="codefrag">Hello Hadoop Goodbye Hadoop</span>
        
</p>
<p>Run the application:</p>
<p>
          
<span class="codefrag">
            $ bin/hadoop jar /user/joe/wordcount.jar org.myorg.WordCount 
              /user/joe/wordcount/input /user/joe/wordcount/output 
          </span>
        
</p>
<p>Output:</p>
<p>
          
<span class="codefrag">
            $ bin/hadoop fs -cat /user/joe/wordcount/output/part-r-00000
          </span>
          
<br>
          
<span class="codefrag">Bye    1</span>
<br>
          
<span class="codefrag">Goodbye    1</span>
<br>
          
<span class="codefrag">Hadoop    2</span>
<br>
          
<span class="codefrag">Hello    2</span>
<br>
          
<span class="codefrag">World    2</span>
<br>
        
</p>
<a name="Bundling+a+data+payload+with+your+application"></a>
<h3 class="h4">Bundling a data payload with your application</h3>
<p> Applications can specify a comma-separated list of paths which
        would be present in the current working directory of the task 
        using the option <span class="codefrag">-files</span>. The <span class="codefrag">-libjars</span>
        option allows applications to add jars to the classpaths of the maps
        and reduces. The option <span class="codefrag">-archives</span> allows them to pass 
        comma separated list of archives as arguments. These archives are 
        unarchived and a link with name of the archive is created in 
        the current working directory of tasks. The mechanism that
        provides this functionality is called the <em>distributed cache</em>.
        More details about the command line options surrounding job launching
        and control of the distributed cache are available at 
        <a href="http://hadoop.apache.org/common/docs/current/commands_default.html"> Hadoop Commands Guide.</a>
</p>
<p>Hadoop ships with some example code in a jar precompiled for you;
        one of these is (another) wordcount program. Here's an example
        invocation of the <span class="codefrag">wordcount</span> example with 
        <span class="codefrag">-libjars</span>, <span class="codefrag">-files</span> and <span class="codefrag">-archives</span>:
        <br>
        
<span class="codefrag"> hadoop jar hadoop-examples.jar wordcount -files cachefile.txt 
        -libjars mylib.jar -archives myarchive.zip input output </span> 
         Here, myarchive.zip will be placed and unzipped into a directory 
         by the name "myarchive.zip"
        </p>
<p> Users can specify a different symbolic name for 
        files and archives passed through -files and -archives option, using #.
        </p>
<p> For example,
        <span class="codefrag"> hadoop jar hadoop-examples.jar wordcount 
        -files dir1/dict.txt#dict1,dir2/dict.txt#dict2 
        -archives mytar.tgz#tgzdir input output </span>
        Here, the files dir1/dict.txt and dir2/dict.txt can be accessed by 
        tasks using the symbolic names dict1 and dict2 respectively.
        And the archive mytar.tgz will be placed and unarchived into a 
        directory by the name tgzdir.
        </p>
<p>The distributed cache is also described in greater detail further
        down in this tutorial.</p>
<a name="Walk-through"></a>
<h3 class="h4">Walk-through</h3>
<p>This section describes the operation of the <span class="codefrag">WordCount</span>
        application shown earlier in this tutorial.</p>
<p>The <a href="api/org/apache/hadoop/mapreduce/Mapper.html"><span class="codefrag">Mapper</span></a>
        implementation (lines 16-30), via the 
        <span class="codefrag">map</span> method (lines 21-29), processes one line at a time,
        as provided by the specified <a href="api/org/apache/hadoop/mapreduce/lib/input/TextInputFormat.html"><span class="codefrag">TextInputFormat</span></a> (line 57). 
        It then splits the line into tokens separated by whitespaces, via the 
        <span class="codefrag">StringTokenizer</span>, and emits a key-value pair of 
        <span class="codefrag">&lt; &lt;word&gt;, 1&gt;</span>.</p>
<p>
          For the given sample input the first map emits:<br>
          
<span class="codefrag">&lt; Hello, 1&gt;</span>
<br>
          
<span class="codefrag">&lt; World, 1&gt;</span>
<br>
          
<span class="codefrag">&lt; Bye, 1&gt;</span>
<br>
          
<span class="codefrag">&lt; World, 1&gt;</span>
<br>
        
</p>
<p>
          The second map emits:<br>
          
<span class="codefrag">&lt; Hello, 1&gt;</span>
<br>
          
<span class="codefrag">&lt; Hadoop, 1&gt;</span>
<br>
          
<span class="codefrag">&lt; Goodbye, 1&gt;</span>
<br>
          
<span class="codefrag">&lt; Hadoop, 1&gt;</span>
<br>
        
</p>
<p>We'll learn more about the number of maps spawned for a given job, and
        how to control them in a fine-grained manner, a bit later in the 
        tutorial.</p>
<p>
<span class="codefrag">WordCount</span> also specifies a <span class="codefrag">combiner</span> (line 
        54). Hence, the output of each map is passed through the local combiner 
        (which is same as the <a href="api/org/apache/hadoop/mapreduce/Reducer.html"><span class="codefrag">Reducer</span></a>
        as per the job configuration) for local aggregation, after being
        sorted on the <em>key</em>s.</p>
<p>
          The output of the first map:<br>
          
<span class="codefrag">&lt; Bye, 1&gt;</span>
<br>
          
<span class="codefrag">&lt; Hello, 1&gt;</span>
<br>
          
<span class="codefrag">&lt; World, 2&gt;</span>
<br>
        
</p>
<p>
          The output of the second map:<br>
          
<span class="codefrag">&lt; Goodbye, 1&gt;</span>
<br>
          
<span class="codefrag">&lt; Hadoop, 2&gt;</span>
<br>
          
<span class="codefrag">&lt; Hello, 1&gt;</span>
<br>
        
</p>
<p>The <a href="api/org/apache/hadoop/mapreduce/Reducer.html"><span class="codefrag">Reducer</span></a>
        implementation (lines 32-43), via the
        <span class="codefrag">reduce</span> method (lines 34-42) just sums up the values,
        which are the occurence counts for each key (i.e. words in this
        example).
        </p>
<p>
          Thus the output of the job is:<br>
          
<span class="codefrag">&lt; Bye, 1&gt;</span>
<br>
          
<span class="codefrag">&lt; Goodbye, 1&gt;</span>
<br>
          
<span class="codefrag">&lt; Hadoop, 2&gt;</span>
<br>
          
<span class="codefrag">&lt; Hello, 2&gt;</span>
<br>
          
<span class="codefrag">&lt; World, 2&gt;</span>
<br>
        
</p>
<p>The <span class="codefrag">run</span> method specifies various facets of the job, such 
        as the input/output paths (passed via the command line), key/value 
        types, input/output formats etc., in the <a href="api/org/apache/hadoop/mapreduce/Job.html"><span class="codefrag">Job</span></a>.
        It then calls the <a href="api/org/apache/hadoop/mapreduce/Job.html#waitForCompletion(boolean)"><span class="codefrag">Job.waitForCompletion()</span></a> (line 63)
        to submit the job to Hadoop and monitor its progress.</p>
<p>We'll learn more about <a href="api/org/apache/hadoop/mapreduce/Job.html"><span class="codefrag">Job</span></a>,
      <a href="api/org/apache/hadoop/mapreduce/Mapper.html"><span class="codefrag">Mapper</span></a>,
        <a href="api/org/apache/hadoop/util/Tool.html"><span class="codefrag">Tool</span></a>
        and other interfaces and classes a bit later in the 
        tutorial.</p>
</div>
    
    
<a name="MapReduce+-+User+Interfaces"></a>
<h2 class="h3">MapReduce - User Interfaces</h2>
<div class="section">
<p>This section provides a reasonable amount of detail on every
        user-facing aspect of the MapReduce framwork. This should help users
        implement, configure and tune their jobs in a fine-grained manner.
        However, please note that the javadoc for each class/interface remains
        the most comprehensive documentation available; this is only meant to
        be a tutorial.
      </p>
<p>Let us first take the
        <a href="api/org/apache/hadoop/mapreduce/Mapper.html"><span class="codefrag">Mapper</span></a> and
        <a href="api/org/apache/hadoop/mapreduce/Reducer.html"><span class="codefrag">Reducer</span></a>
      classes. Applications typically extend them to provide the 
      <span class="codefrag">map</span> and <span class="codefrag">reduce</span> methods.</p>
<p>We will then discuss other core classes including 
      <a href="api/org/apache/hadoop/mapreduce/Job.html"><span class="codefrag">Job</span></a>,
      <a href="api/org/apache/hadoop/mapreduce/Partitioner.html"><span class="codefrag">Partitioner</span></a>,
      <a href="api/org/apache/hadoop/mapreduce/MapContext.html"><span class="codefrag">Context</span></a>,
      <a href="api/org/apache/hadoop/mapreduce/InputFormat.html"><span class="codefrag">InputFormat</span></a>,
      <a href="api/org/apache/hadoop/mapreduce/OutputFormat.html"><span class="codefrag">OutputFormat</span></a>,
      <a href="api/org/apache/hadoop/mapreduce/OutputCommitter.html"><span class="codefrag">OutputCommitter</span></a>
      and others.</p>
<p>Finally, we will wrap up by discussing some useful features of the
      framework such as the <span class="codefrag">DistributedCache</span>, 
      <span class="codefrag">IsolationRunner</span> etc.</p>
<a name="Payload"></a>
<h3 class="h4">Payload</h3>
<p>Applications typically extend the <span class="codefrag">Mapper</span> and
        <span class="codefrag">Reducer</span> classes to provide the <span class="codefrag">map</span> and 
        <span class="codefrag">reduce</span> methods. These form the core of the job.</p>
<a name="Mapper"></a>
<h4>Mapper</h4>
<p>
<a href="api/org/apache/hadoop/mapreduce/Mapper.html"><span class="codefrag">Mapper</span></a>
          maps input key/value pairs to a set of
          intermediate key/value pairs.</p>
<p>Maps are the individual tasks that transform input records into 
          intermediate records. The transformed intermediate records do not need
          to be of the same type as the input records. A given input pair may 
          map to zero or many output pairs.</p>
<p>The Hadoop MapReduce framework spawns one map task for each 
            <a href="api/org/apache/hadoop/mapreduce/InputSplit.html"><span class="codefrag">InputSplit</span></a>
          generated by the
          <a href="api/org/apache/hadoop/mapreduce/InputFormat.html"><span class="codefrag">InputFormat</span></a>
          for the job. An <span class="codefrag">InputSplit</span> is a logical representation of
          a unit of input work for a map task; e.g., a filename and a byte
          range within that file to process. The <span class="codefrag">InputFormat</span> is
          responsible for enumerating the <span class="codefrag">InputSplits</span>, and
          producing a
          <a href="api/org/apache/hadoop/mapreduce/RecordReader.html"><span class="codefrag">RecordReader</span></a>
          which will turn those
          logical work units into actual physical input records.</p>
<p>Overall, <span class="codefrag">Mapper</span> implementations are specified in the
          <a href="api/org/apache/hadoop/mapreduce/Job.html"><span class="codefrag">Job</span></a>,
          a client-side class that describes the job's
          configuration and interfaces with the cluster on behalf of the
          client program. The <span class="codefrag">Mapper</span> itself then is instantiated
          in the running job, and is passed a <a href="api/org/apache/hadoop/mapreduce/MapContext.html"><span class="codefrag">MapContext</span></a> object
          which it can use to configure itself. The <span class="codefrag">Mapper</span>
          contains a <span class="codefrag">run()</span> method which calls its
          <span class="codefrag">setup()</span>
          method once, its <span class="codefrag">map()</span> method for each input record,
          and finally its <span class="codefrag">cleanup()</span> method. All of these methods
          (including <span class="codefrag">run()</span> itself) can be overridden with
          your own code. If you do not override any methods (leaving even
          map as-is), it will act as the <em>identity function</em>, emitting
          each input record as a separate output.</p>
<p>The <span class="codefrag">Context</span> object allows the mapper to interact
          with the rest of the Hadoop system. It includes configuration
          data for the job, as well as interfaces which allow it to emit
          output. The <span class="codefrag">getConfiguration()</span> method returns a
          <a href="api/org/apache/hadoop/conf/Configuration.html">
          <span class="codefrag">Configuration</span></a> which contains configuration data
          for your program. You can set arbitrary (key, value) pairs of
          configuration data in your <span class="codefrag">Job</span>, e.g. with
          <span class="codefrag">Job.getConfiguration().set("myKey", "myVal")</span>,
          and then retrieve this data in your mapper with
          <span class="codefrag">Context.getConfiguration().get("myKey")</span>. This sort of
          functionality is typically done in the Mapper's
          <a href="api/org/apache/hadoop/mapreduce/Mapper.html#setup(org.apache.hadoop.mapreduce.Mapper.Context)"><span class="codefrag">setup()</span></a>
          method.</p>
<p>The
            <a href="api/org/apache/hadoop/mapreduce/Mapper.html#run(org.apache.hadoop.mapreduce.Mapper.Context)"><span class="codefrag">Mapper.run()</span></a>
          method then calls 
          <span class="codefrag">map(KeyInType, ValInType, Context)</span> for 
          each key/value pair in the <span class="codefrag">InputSplit</span> for that task.
          Note that in the WordCount program's map() method, we then emit
          our output data via the <span class="codefrag">Context</span> argument, using its
          <span class="codefrag">write()</span> method.
          </p>
<p>Applications can then override the Mapper's
            <a href="api/org/apache/hadoop/mapreduce/Mapper.html#cleanup(org.apache.hadoop.mapreduce.Mapper.Context)"><span class="codefrag">cleanup()</span></a>
          method to perform any required teardown operations.</p>
<p>Output pairs do not need to be of the same types as input pairs. A 
          given input pair may map to zero or many output pairs.  Output pairs 
          are collected with calls to
          <a href="api/org/apache/hadoop/mapreduce/TaskInputOutputContext.html#write(KEYOUT,%20VALUEOUT)"><span class="codefrag">Context.write(KeyOutType, ValOutType)</span></a>.</p>
<p>Applications can also use the <span class="codefrag">Context</span> to report 
          progress, set application-level status messages and update 
          <span class="codefrag">Counters</span>, or just indicate that they are alive.</p>
<p>All intermediate values associated with a given output key are 
          subsequently grouped by the framework, and passed to the
          <span class="codefrag">Reducer</span>(s) to  determine the final output. Users can 
          control the grouping by specifying a <span class="codefrag">Comparator</span> via 
          <a href="api/org/apache/hadoop/mapreduce/Job.html#setGroupingComparatorClass(java.lang.Class)"><span class="codefrag">Job.setGroupingComparatorClass(Class)</span></a>.
          If a grouping comparator is not specified, then all values with the
          same key will be presented by an unordered <span class="codefrag">Iterable</span> to
          a call to the <span class="codefrag">Reducer.reduce()</span> method.</p>
<p>The <span class="codefrag">Mapper</span> outputs are sorted and
          partitioned per <span class="codefrag">Reducer</span>. The total number of partitions is 
          the same as the number of reduce tasks for the job. Users can control 
          which keys (and hence records) go to which <span class="codefrag">Reducer</span> by 
          implementing a custom
          <a href="api/org/apache/hadoop/mapreduce/Partitioner.html"><span class="codefrag">Partitioner</span></a>.</p>
<p>Users can optionally specify a <span class="codefrag">combiner</span>, via 
          <a href="api/org/apache/hadoop/mapreduce/Job.html#setCombinerClass(java.lang.Class)"><span class="codefrag">Job.setCombinerClass(Class)</span></a>,
          to perform local aggregation of 
          the intermediate outputs, which helps to cut down the amount of data 
          transferred from the <span class="codefrag">Mapper</span> to the <span class="codefrag">Reducer</span>.
          </p>
<p>The intermediate, sorted outputs are always stored in a simple 
          (key-len, key, value-len, value) format. 
          Applications can control if, and how, the 
          intermediate outputs are to be compressed and the 
          <a href="api/org/apache/hadoop/io/compress/CompressionCodec.html">
          CompressionCodec</a> to be used via the <span class="codefrag">Job</span>.
          </p>
<a name="How+Many+Maps%3F"></a>
<h5>How Many Maps?</h5>
<p>The number of maps is usually driven by the total size of the 
            inputs, that is, the total number of blocks of the input files.</p>
<p>The right level of parallelism for maps seems to be around 10-100 
            maps per-node, although it has been set up to 300 maps for very 
            cpu-light map tasks. Task setup takes awhile, so it is best if the 
            maps take at least a minute to execute.</p>
<p>Thus, if you expect 10TB of input data and have a blocksize of 
              <span class="codefrag">128MB</span>, you'll end up with 82,000 maps, unless the
              <span class="codefrag">mapreduce.job.maps</span> parameter
            (which only provides a hint to the
            framework) is used to set it even higher. Ultimately, the number
            of tasks is controlled by the number of splits returned by the
            <a href="api/org/apache/hadoop/mapreduce/InputFormat.html#getSplits(org.apache.hadoop.mapreduce.JobContext)"><span class="codefrag">InputFormat.getSplits()</span></a> method (which you can
            override).
            </p>
<a name="Reducer"></a>
<h4>Reducer</h4>
<p>
<a href="api/org/apache/hadoop/mapreduce/Reducer.html"><span class="codefrag">Reducer</span></a>
          reduces a set of intermediate values which
          share a key to a (usually smaller) set of values.</p>
<p>The number of reduces for the job is set by the user via <a href="api/org/apache/hadoop/mapreduce/Job.html#setNumReduceTasks(int)"><span class="codefrag">Job.setNumReduceTasks(int)</span></a>.</p>
<p>The API of <span class="codefrag">Reducer</span> is very similar to that of
          <span class="codefrag">Mapper</span>; there's a <a href="api/org/apache/hadoop/mapreduce/Reducer.html#run(org.apache.hadoop.mapreduce.Reducer.Context)"><span class="codefrag">run()</span></a> method that receives
          a <a href="api/org/apache/hadoop/mapreduce/ReduceContext.html"><span class="codefrag">Context</span></a> containing the job's configuration as
          well as interfacing methods that return data from the reducer itself
          back to the framework. The <span class="codefrag">run()</span> method calls <a href="api/org/apache/hadoop/mapreduce/Reducer.html#setup(org.apache.hadoop.mapreduce.Reducer.Context)"><span class="codefrag">setup()</span></a> once,
          <a href="api/org/apache/hadoop/mapreduce/Reducer.html#reduce(KEYIN,%20java.lang.Iterable,%20org.apache.hadoop.mapreduce.Reducer.Context)"><span class="codefrag">reduce()</span></a> once for each key associated with the
          reduce task, and <a href="api/org/apache/hadoop/mapreduce/Reducer.html#cleanup(org.apache.hadoop.mapreduce.Reducer.Context)"><span class="codefrag">cleanup()</span></a>
          once at the end. Each of these methods
          can access the job's configuration data by using
          <span class="codefrag">Context.getConfiguration()</span>.</p>
<p>As in <span class="codefrag">Mapper</span>, any or all of these methods can be
          overridden with custom implementations. If none of these methods are
          overridden, the default reducer operation is the identity function;
          values are passed through without further processing.</p>
<p>The heart of <span class="codefrag">Reducer</span> is its <span class="codefrag">reduce()</span>
          method. This is called once per key; the second argument is an
          <span class="codefrag">Iterable</span> which returns all the values associated with
          that key. In the WordCount example, this is all of the 1's or other
          partial counts associated with a given word. The Reducer should
          emit its final output (key, value) pairs with the
          <span class="codefrag">Context.write()</span> method. It may emit 0, 1, or more
          (key, value) pairs for each input.</p>
<p>
<span class="codefrag">Reducer</span> has 3 primary phases: shuffle, sort and reduce.
          </p>
<a name="Shuffle"></a>
<h5>Shuffle</h5>
<p>Input to the <span class="codefrag">Reducer</span> is the sorted output of the
            mappers. In this phase the framework fetches the relevant partition 
            of the output of all the mappers, via HTTP.</p>
<a name="Sort"></a>
<h5>Sort</h5>
<p>The framework groups <span class="codefrag">Reducer</span> inputs by keys (since 
            different mappers may have output the same key) in this stage.</p>
<p>The shuffle and sort phases occur simultaneously; while 
            map-outputs are being fetched they are merged.</p>
<a name="Secondary+Sort"></a>
<h5>Secondary Sort</h5>
<p>If equivalence rules for grouping the intermediate keys are 
              required to be different from those for grouping keys before 
              reduction, then one may specify a <span class="codefrag">Comparator</span> via 
              <a href="api/org/apache/hadoop/mapreduce/Job.html#setGroupingComparatorClass(java.lang.Class)">Job.setGroupingComparatorClass(Class)</a>. Since this
              can be used to control how intermediate keys are grouped, these
              can be used in conjunction to simulate <em>secondary sort on
              values</em>.</p>
<a name="Reduce"></a>
<h5>Reduce</h5>
<p>In this phase the 
              <a href="api/org/apache/hadoop/mapreduce/Reducer.html#reduce(KEYIN,%20java.lang.Iterable,%20org.apache.hadoop.mapreduce.Reducer.Context)"><span class="codefrag">reduce(MapOutKeyType,
            Iterable&lt;MapOutValType&gt;, Context)</span></a>
            method is called for each <span class="codefrag">&lt;key, (list of
            values)&gt;</span> pair in the grouped inputs.</p>
<p>The output of the reduce task is typically written to the 
            <a href="api/org/apache/hadoop/fs/FileSystem.html">
            FileSystem</a> via 
            <span class="codefrag">Context.write(ReduceOutKeyType, ReduceOutValType)</span>.</p>
<p>Applications can use the <span class="codefrag">Context</span> to report 
            progress, set application-level status messages and update 
            <a href="api/org/apache/hadoop/mapreduce/Counters.html"><span class="codefrag">Counters</span></a>,
            or just indicate that they are alive.</p>
<p>The output of the <span class="codefrag">Reducer</span> is <em>not sorted</em>.</p>
<a name="How+Many+Reduces%3F"></a>
<h5>How Many Reduces?</h5>
<p>The right number of reduces seems to be <span class="codefrag">0.95</span> or 
            <span class="codefrag">1.75</span> multiplied by (&lt;<em>no. of nodes</em>&gt; * 
            <span class="codefrag">mapreduce.tasktracker.reduce.tasks.maximum</span>).</p>
<p>With <span class="codefrag">0.95</span> all of the reduces can launch immediately 
            and start transfering map outputs as the maps finish. With 
            <span class="codefrag">1.75</span> the faster nodes will finish their first round of 
            reduces and launch a second wave of reduces doing a much better job 
            of load balancing.</p>
<p>Increasing the number of reduces increases the framework
            overhead, but increases load balancing and lowers the cost of
            failures.</p>
<p>The scaling factors above are slightly less than whole numbers to 
            reserve a few reduce slots in the framework for speculative-tasks
            and failed tasks.</p>
<a name="Reducer+NONE"></a>
<h5>Reducer NONE</h5>
<p>It is legal to set the number of reduce-tasks to <em>zero</em> if 
            no reduction is desired.</p>
<p>In this case the outputs of the map-tasks go directly to the
            <span class="codefrag">FileSystem</span>, into the output path set by 
            <a href="api/org/apache/hadoop/mapreduce/lib/output/FileOutputFormat.html#setOutputPath(org.apache.hadoop.mapreduce.Job,%20org.apache.hadoop.fs.Path)">
            setOutputPath(Path)</a>. The framework does not sort the 
            map-outputs before writing them out to the <span class="codefrag">FileSystem</span>.
            </p>
<a name="Mark-Reset"></a>
<h5>Mark-Reset</h5>
<p>While applications iterate through the values for a given key, it
              is possible to mark the current position and later reset the
              iterator to this position and continue the iteration process.
              The corresponding methods are <span class="codefrag">mark()</span> and
              <span class="codefrag">reset()</span>. 
            </p>
<p>
<span class="codefrag">mark()</span> and <span class="codefrag">reset()</span> can be called any
            number of times during the iteration cycle. The <span class="codefrag">reset()</span>
            method will reset the iterator to the last record before a call to
            the previous <span class="codefrag">mark()</span>.
            </p>
<p>This functionality is available only with the new context based
               reduce iterator.
            </p>
<p> The following code snippet demonstrates the use of this 
                functionality.
            </p>
<a name="Source+Code-N10808"></a>
<h5>Source Code</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
            
<tr>
<td colspan="1" rowspan="1">
            <span class="codefrag">
              public void reduce(IntWritable key, 
                Iterable&lt;IntWritable&gt; values,
                Context context) throws IOException, InterruptedException {
            </span>
            </td>
</tr>

            
<tr>
<td colspan="1" rowspan="1"></td>
</tr>

            
<tr>
<td colspan="1" rowspan="1">
            <span class="codefrag">
                &nbsp;&nbsp;
                MarkableIterator&lt;IntWritable&gt; mitr = 
                  new MarkableIterator&lt;IntWritable&gt;(values.iterator());
            </span>
            </td>
</tr>

            
<tr>
<td colspan="1" rowspan="1"></td>
</tr>

            
<tr>
<td colspan="1" rowspan="1">
            <span class="codefrag">
                &nbsp;&nbsp;
                // Mark the position
            </span>
            </td>
</tr>

            
<tr>
<td colspan="1" rowspan="1">
            <span class="codefrag">
                &nbsp;&nbsp;
                mitr.mark();
            </span>
            </td>
</tr>

            
<tr>
<td colspan="1" rowspan="1"></td>
</tr>

            
<tr>
<td colspan="1" rowspan="1">
            <span class="codefrag">
                &nbsp;&nbsp;
                while (mitr.hasNext()) {
            </span>
            </td>
</tr>

            
<tr>
<td colspan="1" rowspan="1">
            <span class="codefrag">
                  &nbsp;&nbsp;&nbsp;&nbsp;
                  i = mitr.next();
            </span>
            </td>
</tr>

            
<tr>
<td colspan="1" rowspan="1">
            <span class="codefrag">
                  &nbsp;&nbsp;&nbsp;&nbsp;
                  // Do the necessary processing
            </span>
            </td>
</tr>

            
<tr>
<td colspan="1" rowspan="1">
            <span class="codefrag">
                &nbsp;&nbsp;
                }
            </span>
            </td>
</tr>

            
<tr>
<td colspan="1" rowspan="1"></td>
</tr>

            
<tr>
<td colspan="1" rowspan="1">
            <span class="codefrag">
                &nbsp;&nbsp;
                // Reset
            </span>
            </td>
</tr>

            
<tr>
<td colspan="1" rowspan="1">
            <span class="codefrag">
                &nbsp;&nbsp;
                mitr.reset();
            </span>
            </td>
</tr>

            
<tr>
<td colspan="1" rowspan="1"></td>
</tr>

            
<tr>
<td colspan="1" rowspan="1">
            <span class="codefrag">
                &nbsp;&nbsp;
                // Iterate all over again. Since mark was called before the first
            </span>
            </td>
</tr>

            
<tr>
<td colspan="1" rowspan="1">
            <span class="codefrag">
                &nbsp;&nbsp;
                // call to mitr.next() in this example, we will iterate over all
            </span>
            </td>
</tr>

            
<tr>
<td colspan="1" rowspan="1">
            <span class="codefrag">
                &nbsp;&nbsp;
                // the values now
            </span>
            </td>
</tr>

            
<tr>
<td colspan="1" rowspan="1">
            <span class="codefrag">
                &nbsp;&nbsp;
                while (mitr.hasNext()) {
            </span>
            </td>
</tr>

            
<tr>
<td colspan="1" rowspan="1">
            <span class="codefrag">
                  &nbsp;&nbsp;&nbsp;&nbsp;
                  i = mitr.next();
            </span>
            </td>
</tr>

            
<tr>
<td colspan="1" rowspan="1">
            <span class="codefrag">
                  &nbsp;&nbsp;&nbsp;&nbsp;
                  // Do the necessary processing
            </span>
            </td>
</tr>

            
<tr>
<td colspan="1" rowspan="1">
            <span class="codefrag">
                &nbsp;&nbsp;
                }
            </span>
            </td>
</tr>

            
<tr>
<td colspan="1" rowspan="1"></td>
</tr>

            
<tr>
<td colspan="1" rowspan="1">
            <span class="codefrag">
              }
            </span>
            </td>
</tr>

            
</table>
<a name="Partitioner"></a>
<h4>Partitioner</h4>
<p>
<a href="api/org/apache/hadoop/mapreduce/Partitioner.html"><span class="codefrag">
          Partitioner</span></a> partitions the key space.</p>
<p>Partitioner controls the partitioning of the keys of the 
          intermediate map-outputs. The key (or a subset of the key) is used to 
          derive the partition, typically by a <em>hash function</em>. The total 
          number of partitions is the same as the number of reduce tasks for the 
          job. Hence this controls which of the <span class="codefrag">m</span> reduce tasks the 
          intermediate key (and hence the record) is sent to for reduction.</p>
<p>
<a href="api/org/apache/hadoop/mapreduce/lib/partition/HashPartitioner.html"><span class="codefrag">HashPartitioner</span></a> is the default
          <span class="codefrag">Partitioner</span>.</p>
<a name="Reporting+Progress"></a>
<h4>Reporting Progress</h4>
<p>Via the mapper or reducer's Context, MapReduce applications can
          report progress, set application-level status messages and update 
          <a href="api/org/apache/hadoop/mapreduce/Counters.html"><span class="codefrag">Counters</span></a>.</p>
<p>
<span class="codefrag">Mapper</span> and <span class="codefrag">Reducer</span> implementations can
          use the <span class="codefrag">Context</span> to report progress or just indicate 
          that they are alive. In scenarios where the application takes a
          significant amount of time to process individual key/value pairs, 
          this is crucial since the framework might assume that the task has 
          timed-out and kill that task. Another way to avoid this is to 
          set the configuration parameter <span class="codefrag">mapreduce.task.timeout</span>
          to a high-enough value (or even set it to <em>zero</em> for no
          time-outs).
          </p>
<p>Applications can also update <span class="codefrag">Counters</span> using the 
          <span class="codefrag">Context</span>.</p>
<p>Hadoop MapReduce comes bundled with a 
        library of generally useful mappers, reducers, and partitioners
        in the <a href="api/org/apache/hadoop/mapreduce/lib/package-summary.html"><span class="codefrag">org.apache.hadoop.mapreduce.lib</span></a> package.</p>
<a name="Job+Configuration"></a>
<h3 class="h4">Job Configuration</h3>
<p>The <span class="codefrag">Job</span> represents a MapReduce job configuration.
        The actual state for this object is written to an underlying instance of
        <a href="api/org/apache/hadoop/conf/Configuration.html">Configuration</a>.</p>
<p>
<a href="api/org/apache/hadoop/mapreduce/Job.html"><span class="codefrag">Job</span></a> is the primary interface for a user to describe
        a MapReduce job to the Hadoop framework for execution. The framework 
        tries to faithfully execute the job as described by <span class="codefrag">Job</span>, 
        however:</p>
<ul>
          
<li>
            Some configuration parameters may have been marked as 
            <a href="api/org/apache/hadoop/conf/Configuration.html#FinalParams">
            final</a> by administrators and hence cannot be altered.
          </li>
          
<li>
            While some job parameters are straight-forward to set (e.g. 
            <span class="codefrag">setNumReduceTasks(int)</span>), other parameters interact
            subtly with  the rest of the framework and/or job configuration
            and are more complex to set (e.g. <span class="codefrag">mapreduce.job.maps</span>).
          </li>
        
</ul>
<p>The <span class="codefrag">Job</span> is typically used to specify the 
        <span class="codefrag">Mapper</span>, combiner (if any), <span class="codefrag">Partitioner</span>, 
        <span class="codefrag">Reducer</span>, <span class="codefrag">InputFormat</span>, 
        <span class="codefrag">OutputFormat</span> and <span class="codefrag">OutputCommitter</span> 
        implementations. <span class="codefrag">Job</span> also 
        indicates the set of input files 
        (<a href="api/org/apache/hadoop/mapreduce/lib/input/FileInputFormat.html#setInputPaths(org.apache.hadoop.mapreduce.Job,%20org.apache.hadoop.fs.Path...)">setInputPaths(Job, Path...)</a>
        /<a href="api/org/apache/hadoop/mapreduce/lib/input/FileInputFormat.html#addInputPath(org.apache.hadoop.mapreduce.Job,%20org.apache.hadoop.fs.Path)">addInputPath(Job, Path)</a>)
        and (<a href="api/org/apache/hadoop/mapreduce/lib/input/FileInputFormat.html#setInputPaths(org.apache.hadoop.mapreduce.Job,%20java.lang.String)">setInputPaths(Job, String)</a>
        /<a href="api/org/apache/hadoop/mapreduce/lib/input/FileInputFormat.html#addInputPaths(org.apache.hadoop.mapreduce.Job,%20java.lang.String)">addInputPaths(Job, String)</a>)
        and where the output files should be written
        (<a href="api/org/apache/hadoop/mapreduce/lib/output/FileOutputFormat.html#setOutputPath(org.apache.hadoop.mapreduce.Job,%20org.apache.hadoop.fs.Path)">setOutputPath(Path)</a>).</p>
<p>Optionally, <span class="codefrag">Job</span> is used to specify other advanced 
        facets of the job such as the <span class="codefrag">Comparator</span> to be used, files 
        to be put in the <span class="codefrag">DistributedCache</span>, whether intermediate 
        and/or job outputs are to be compressed (and how), debugging via 
        user-provided scripts,
        whether job tasks can be executed in a <em>speculative</em> manner 
        (<a href="api/org/apache/hadoop/mapreduce/Job.html#setMapSpeculativeExecution(boolean)">setMapSpeculativeExecution(boolean)</a>)/(<a href="api/org/apache/hadoop/mapreduce/Job.html#setReduceSpeculativeExecution(boolean)">setReduceSpeculativeExecution(boolean)</a>)
        , maximum number of attempts per task
        (<a href="api/org/apache/hadoop/mapreduce/Job.html#setMaxMapAttempts(int)">setMaxMapAttempts(int)</a>/<a href="api/org/apache/hadoop/mapreduce/Job.html#setMaxReduceAttempts(int)">setMaxReduceAttempts(int)</a>) 
        , percentage of tasks failure which can be tolerated by the job
        (Job.getConfiguration().setInt(Job.MAP_FAILURES_MAX_PERCENT,
        int)/Job.getConfiguration().setInt(Job.REDUCE_FAILURES_MAX_PERCENT,
        int)), etc.</p>
<p>Of course, users can use <span class="codefrag">Job.getConfiguration()</span> to get
        access to the underlying configuration state, and can then use
        <a href="api/org/apache/hadoop/conf/Configuration.html#set(java.lang.String, java.lang.String)">set(String,
          String)</a>/<a href="api/org/apache/hadoop/conf/Configuration.html#get(java.lang.String, java.lang.String)">get(String, String)</a>
        to set/get arbitrary parameters needed by applications. However, use the 
        <span class="codefrag">DistributedCache</span> for large amounts of (read-only) data.</p>
<a name="Task+Execution+%26+Environment"></a>
<h3 class="h4">Task Execution &amp; Environment</h3>
<p>The <span class="codefrag">TaskTracker</span> executes the <span class="codefrag">Mapper</span>/ 
        <span class="codefrag">Reducer</span>  <em>task</em> as a child process in a separate jvm.
        </p>
<p>The child-task inherits the environment of the parent 
        <span class="codefrag">TaskTracker</span>. The user can specify additional options to the
        child-jvm via the <span class="codefrag">mapreduce.{map|reduce}.java.opts</span>
        configuration parameter in the job configuration such as non-standard 
         paths for the run-time linker to search shared libraries via 
        <span class="codefrag">-Djava.library.path=&lt;&gt;</span> etc. If the 
        <span class="codefrag">mapreduce.{map|reduce}.java.opts</span> parameters contains the
        symbol <em>@taskid@</em> it is interpolated with value of 
        <span class="codefrag">taskid</span> of the Map or Reduce task.</p>
<p>Here is an example with multiple arguments and substitutions, 
        showing jvm GC logging, and start of a passwordless JVM JMX agent so that
        it can connect with jconsole and the likes to watch child memory, 
        threads and get thread dumps. It also sets the maximum heap-size of the 
        map and reduce child jvm to 512MB &amp; 1024MB respectively. It also 
        adds an additional path to the <span class="codefrag">java.library.path</span> of the 
        child-jvm.</p>
<p>
          
<span class="codefrag">&lt;property&gt;</span>
<br>
          &nbsp;&nbsp;<span class="codefrag">&lt;name&gt;mapreduce.map.java.opts&lt;/name&gt;</span>
<br>
          &nbsp;&nbsp;<span class="codefrag">&lt;value&gt;</span>
<br>
          &nbsp;&nbsp;&nbsp;&nbsp;<span class="codefrag">
                    -Xmx512M -Djava.library.path=/home/mycompany/lib
                    -verbose:gc -Xloggc:/tmp/@taskid@.gc</span>
<br>
          &nbsp;&nbsp;&nbsp;&nbsp;<span class="codefrag">
                    -Dcom.sun.management.jmxremote.authenticate=false 
                    -Dcom.sun.management.jmxremote.ssl=false</span>
<br>
          &nbsp;&nbsp;<span class="codefrag">&lt;/value&gt;</span>
<br>
          
<span class="codefrag">&lt;/property&gt;</span>
        
</p>
<p>
          
<span class="codefrag">&lt;property&gt;</span>
<br>
          &nbsp;&nbsp;<span class="codefrag">&lt;name&gt;mapreduce.reduce.java.opts&lt;/name&gt;</span>
<br>
          &nbsp;&nbsp;<span class="codefrag">&lt;value&gt;</span>
<br>
          &nbsp;&nbsp;&nbsp;&nbsp;<span class="codefrag">
                    -Xmx1024M -Djava.library.path=/home/mycompany/lib
                    -verbose:gc -Xloggc:/tmp/@taskid@.gc</span>
<br>
          &nbsp;&nbsp;&nbsp;&nbsp;<span class="codefrag">
                    -Dcom.sun.management.jmxremote.authenticate=false 
                    -Dcom.sun.management.jmxremote.ssl=false</span>
<br>
          &nbsp;&nbsp;<span class="codefrag">&lt;/value&gt;</span>
<br>
          
<span class="codefrag">&lt;/property&gt;</span>
        
</p>
<p>In addition the <span class="codefrag">mapreduce.{map|reduce}.env</span> properties can be used
        to add environment variables to the Map or Reduce child process.
        </p>
<a name="Configuring+Memory+Requirements+For+A+Job"></a>
<h4>Configuring Memory Requirements For A Job</h4>
<p>
         MapReduce tasks are launched with some default memory limits
         that are provided by the system or by the cluster's administrators.
         Memory intensive jobs might need to use more than these default
         values. Hadoop has some configuration options that allow these to 
         be changed.
         Without such modifications, memory intensive jobs could fail due
         to <span class="codefrag">OutOfMemory</span> errors in tasks or could get killed
         when the limits are enforced by the system. This section describes
         the various options that can be used to configure specific
         memory requirements.
         </p>
<ul>
         
           
<li>
           
<span class="codefrag">mapreduce.{map|reduce}.java.opts</span>: If the task
           requires more Java heap space, this option must be used. The
           value of this option should pass the desired heap using the JVM
           option -Xmx. For example, to use 1G of heap space, the option
           should be passed in as -Xmx1024m. Note that other JVM options
           are also passed using the same option. Hence, append the
           heap space option along with other options already configured.
           </li>
         
           
<li>
           
<span class="codefrag">mapreduce.{map|reduce}.ulimit</span>: The slaves where
           tasks are run could be configured with a ulimit value that
           applies a limit to every process that is launched on the slave.
           If the task, or any child that the task launches (like in
           streaming), requires more than the configured limit, this option
           must be used. The value is given in kilobytes. For example, to
           increase the ulimit to 1G, the option should be set to 1048576.
           Note that this value is a per process limit. Since it applies 
           to the JVM as well, the heap space given to the JVM through 
           the <span class="codefrag">mapreduce.{map|reduce}.java.opts</span> should be less
           than the value configured for the ulimit. Otherwise the JVM
           will not start.
           </li>
           
           
<li>
           
<span class="codefrag">mapreduce.{map|reduce}.memory.mb</span>: In some 
           environments, administrators might have configured a total limit
           on the virtual memory used by the entire process tree for a task, 
           including all processes launched recursively by the task or 
           its children, like in streaming. More details about this can be
           found in the section on 
           <a href="http://hadoop.apache.org/common/docs/current/cluster_setup.html#Configuring+Memory+Parameters+for+MapReduce+Jobs">
           Monitoring Task Memory Usage</a> in the Cluster SetUp guide.
           If a task requires more virtual memory for its entire tree, 
           this option 
           must be used. The value is given in MB. For example, to set 
           the limit to 1G, the option should be set to 1024. Note that this 
           value does not automatically influence the per process ulimit or 
           heap space. Hence, you may need to set those parameters as well 
           (as described above) in order to give your tasks the right amount 
           of memory.
           </li>
          
           
<li>
           
<span class="codefrag">mapreduce.{map|reduce}.memory.physical.mb</span>: 
           This parameter is similar to 
           <span class="codefrag">mapreduce.{map|reduce}.memory.mb</span>, except it specifies
           how much physical memory is required by a task for its entire
           tree of processes. The parameter is applicable if administrators
           have configured a total limit on the physical memory used by
           all MapReduce tasks.
           </li>
 
         
</ul>
<p>
         As seen above, each of the options can be specified separately for
         map and reduce tasks. It is typically the case that the different
         types of tasks have different memory requirements. Hence different
         values can be set for the corresponding options.
         </p>
<p>
         The memory available to some parts of the framework is also
         configurable. In map and reduce tasks, performance may be influenced
         by adjusting parameters influencing the concurrency of operations and
         the frequency with which data will hit disk. Monitoring the filesystem
         counters for a job- particularly relative to byte counts from the map
         and into the reduce- is invaluable to the tuning of these
         parameters.
         </p>
<p>
         Note: The memory related configuration options described above 
         are used only for configuring the launched child tasks from the 
         tasktracker. Configuring the memory options for daemons is documented 
         under
         <a href="http://hadoop.apache.org/common/docs/current/cluster_setup.html#Configuring+the+Environment+of+the+Hadoop+Daemons">
         Configuring the Environment of the Hadoop Daemons</a> (Cluster Setup).
         </p>
<a name="Map+Parameters"></a>
<h4>Map Parameters</h4>
<p>A record emitted from a map and its metadata will be serialized
          into a buffer. As described in the following options, when the record
          data exceed a threshold, the contents of this buffer will be sorted
          and written to disk in the background (a "spill") while the map
          continues to output records. If the remainder of the buffer fills
          during the spill, the map thread will block. When the map is
          finished, any buffered records are written to disk and all on-disk
          segments are merged into a single file. Minimizing the number of
          spills to disk <em>can</em> decrease map time, but a larger buffer
          also decreases the memory available to the mapper.</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
            
<tr>
<th colspan="1" rowspan="1">Name</th><th colspan="1" rowspan="1">Type</th><th colspan="1" rowspan="1">Description</th>
</tr>
            
<tr>
<td colspan="1" rowspan="1">mapreduce.task.io.sort.mb</td><td colspan="1" rowspan="1">int</td>
                <td colspan="1" rowspan="1">The cumulative size of the serialization and accounting
                buffers storing records emitted from the map, in megabytes.
                </td>
</tr>
            
<tr>
<td colspan="1" rowspan="1">mapreduce.map.sort.spill.percent</td><td colspan="1" rowspan="1">float</td>
                <td colspan="1" rowspan="1">This is the threshold for the accounting and serialization
                buffer. When this percentage of the <span class="codefrag">io.sort.mb</span> has
                filled, its contents will be spilled to disk in the background.
                Note that a higher value may decrease the number of- or even
                eliminate- merges, but will also increase the probability of
                the map task getting blocked. The lowest average map times are
                usually obtained by accurately estimating the size of the map
                output and preventing multiple spills.</td>
</tr>
          
</table>
<p>Other notes</p>
<ul>
            
<li>If the spill threshold is exceeded while a spill is in
            progress, collection will continue until the spill is finished. For
            example, if <span class="codefrag">mapreduce.map.sort.spill.percent</span> is set to
            0.33, and the remainder of the buffer is filled while the spill
            runs, the next spill will include all the collected records, or
            0.66 of the buffer, and will not generate additional spills. In
            other words, the thresholds are defining triggers, not
            blocking.</li>
            
<li>A record larger than the serialization buffer will first
            trigger a spill, then be spilled to a separate file. It is
            undefined whether or not this record will first pass through the
            combiner.</li>
          
</ul>
<a name="Shuffle%2FReduce+Parameters"></a>
<h4>Shuffle/Reduce Parameters</h4>
<p>As described previously, each reduce fetches the output assigned
          to it by the Partitioner via HTTP into memory and periodically
          merges these outputs to disk. If intermediate compression of map
          outputs is turned on, each output is decompressed into memory. The
          following options affect the frequency of these merges to disk prior
          to the reduce and the memory allocated to map output during the
          reduce.</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
            
<tr>
<th colspan="1" rowspan="1">Name</th><th colspan="1" rowspan="1">Type</th><th colspan="1" rowspan="1">Description</th>
</tr>
            
<tr>
<td colspan="1" rowspan="1">mapreduce.task.io.sort.factor</td><td colspan="1" rowspan="1">int</td>
                <td colspan="1" rowspan="1">Specifies the number of segments on disk to be merged at
                the same time. It limits the number of open files and
                compression codecs during the merge. If the number of files
                exceeds this limit, the merge will proceed in several passes.
                Though this limit also applies to the map, most jobs should be
                configured so that hitting this limit is unlikely
                there.</td>
</tr>
            
<tr>
<td colspan="1" rowspan="1">mapreduce.reduce.merge.inmem.threshold</td><td colspan="1" rowspan="1">int</td>
                <td colspan="1" rowspan="1">The number of sorted map outputs fetched into memory
                before being merged to disk. Like the spill thresholds in the
                preceding note, this is not defining a unit of partition, but
                a trigger. In practice, this is usually set very high (1000)
                or disabled (0), since merging in-memory segments is often
                less expensive than merging from disk (see notes following
                this table). This threshold influences only the frequency of
                in-memory merges during the shuffle.</td>
</tr>
            
<tr>
<td colspan="1" rowspan="1">mapreduce.reduce.shuffle.merge.percent</td><td colspan="1" rowspan="1">float</td>
                <td colspan="1" rowspan="1">The memory threshold for fetched map outputs before an
                in-memory merge is started, expressed as a percentage of
                memory allocated to storing map outputs in memory. Since map
                outputs that can't fit in memory can be stalled, setting this
                high may decrease parallelism between the fetch and merge.
                Conversely, values as high as 1.0 have been effective for
                reduces whose input can fit entirely in memory. This parameter
                influences only the frequency of in-memory merges during the
                shuffle.</td>
</tr>
            
<tr>
<td colspan="1" rowspan="1">mapreduce.reduce.shuffle.input.buffer.percent</td><td colspan="1" rowspan="1">float</td>
                <td colspan="1" rowspan="1">The percentage of memory- relative to the maximum heapsize
                as typically specified in <span class="codefrag">mapreduce.reduce.java.opts</span>-
                that can be allocated to storing map outputs during the
                shuffle. Though some memory should be set aside for the
                framework, in general it is advantageous to set this high
                enough to store large and numerous map outputs.</td>
</tr>
            
<tr>
<td colspan="1" rowspan="1">mapreduce.reduce.input.buffer.percent</td><td colspan="1" rowspan="1">float</td>
                <td colspan="1" rowspan="1">The percentage of memory relative to the maximum heapsize
                in which map outputs may be retained during the reduce. When
                the reduce begins, map outputs will be merged to disk until
                those that remain are under the resource limit this defines.
                By default, all map outputs are merged to disk before the
                reduce begins to maximize the memory available to the reduce.
                For less memory-intensive reduces, this should be increased to
                avoid trips to disk.</td>
</tr>
          
</table>
<p>Other notes</p>
<ul>
            
<li>If a map output is larger than 25 percent of the memory
            allocated to copying map outputs, it will be written directly to
            disk without first staging through memory.</li>
            
<li>When running with a combiner, the reasoning about high merge
            thresholds and large buffers may not hold. For merges started
            before all map outputs have been fetched, the combiner is run
            while spilling to disk. In some cases, one can obtain better
            reduce times by spending resources combining map outputs- making
            disk spills small and parallelizing spilling and fetching- rather
            than aggressively increasing buffer sizes.</li>
            
<li>When merging in-memory map outputs to disk to begin the
            reduce, if an intermediate merge is necessary because there are
            segments to spill and at least 
            <span class="codefrag">mapreduce.task.io.sort.factor</span>
            segments already on disk, the in-memory map outputs will be part
            of the intermediate merge.</li>
          
</ul>
<a name="Directory+Structure"></a>
<h4> Directory Structure </h4>
<p>The task tracker has local directory,
        <span class="codefrag"> ${mapreduce.cluster.local.dir}/taskTracker/</span> to create
        localized cache and localized job. It can define multiple local
        directories (spanning multiple disks) and then each filename is assigned
        to a semi-random local directory. When the job starts, task tracker 
        creates a localized job directory relative to the local directory
        specified in the configuration. Thus the task tracker directory 
        structure looks as following: </p>
<ul>
        
<li>
<span class="codefrag">${mapreduce.cluster.local.dir}/taskTracker/distcache/</span> :
        The public distributed cache for the jobs of all users. This directory
        holds the localized public distributed cache. Thus localized public
        distributed cache is shared among all the tasks and jobs of all users.
        </li>
        
<li>
<span class="codefrag">${mapreduce.cluster.local.dir}/taskTracker/$user/distcache/
        </span> :
        The private distributed cache for the jobs of the specific user. This
        directory holds the localized private distributed cache. Thus localized
        private distributed cache is shared among all the tasks and jobs of the
        specific user only. It is not accessible to jobs of other users.
        </li>
        
<li>
<span class="codefrag">
        ${mapreduce.cluster.local.dir}/taskTracker/$user/jobcache/$jobid/
        </span> : The localized job directory
        <ul>
        
<li>
<span class="codefrag">
        ${mapreduce.cluster.local.dir}/taskTracker/$user/jobcache/$jobid/work/
        </span>
        : The job-specific shared directory. The tasks can use this space as 
        scratch space and share files among them. This directory is exposed
        to the users through the configuration property  
        <span class="codefrag">mapreduce.job.local.dir</span>. It is available as System property
        also. So, users (streaming etc.) can call 
        <span class="codefrag">System.getProperty("mapreduce.job.local.dir")</span> to access the 
        directory.</li>
        
<li>
<span class="codefrag">
        ${mapreduce.cluster.local.dir}/taskTracker/$user/jobcache/$jobid/jars/
        </span>
        : The jars directory, which has the job jar file and expanded jar.
        The <span class="codefrag">job.jar</span> is the application's jar file that is
        automatically distributed to each machine. Any library jars that are
        dependencies of the application code may be packaged inside this jar in
        a <span class="codefrag">lib/</span> directory.
        This directory is extracted from <span class="codefrag">job.jar</span> and its contents
        are automatically added to the classpath for each task.
        The job.jar location is accessible to the application through the API
        <a href="api/org/apache/hadoop/mapreduce/task/JobContextImpl.html#getJar()"> 
        Job.getJar() </a>. To access the unjarred directory,
        Job.getJar().getParent() can be called.</li>
        
<li>
<span class="codefrag">
        ${mapreduce.cluster.local.dir}/taskTracker/$user/jobcache/$jobid/job.xml
        </span>
        : The job.xml file, the generic job configuration, localized for 
        the job. </li>
        
<li>
<span class="codefrag">
        ${mapreduce.cluster.local.dir}/taskTracker/$user/jobcache/$jobid/$taskid
        </span>
        : The task directory for each task attempt. Each task directory
        again has the following structure :
        <ul>
        
<li>
<span class="codefrag">
        ${mapreduce.cluster.local.dir}/taskTracker/$user/jobcache/$jobid/$taskid/job.xml
        </span>
        : A job.xml file, task localized job configuration, Task localization
        means that properties have been set that are specific to
        this particular task within the job. The properties localized for 
        each task are described below.</li>
        
<li>
<span class="codefrag">
        ${mapreduce.cluster.local.dir}/taskTracker/$user/jobcache/$jobid/$taskid/output
        </span>
        : A directory for intermediate output files. This contains the
        temporary map reduce data generated by the framework
        such as map output files etc. </li>
        
<li>
<span class="codefrag">
        ${mapreduce.cluster.local.dir}/taskTracker/$user/jobcache/$jobid/$taskid/work
        </span>
        : The curernt working directory of the task. 
        With <a href="#Task+JVM+Reuse">jvm reuse</a> enabled for tasks, this 
        directory will be the directory on which the jvm has started</li>
        
<li>
<span class="codefrag">
        ${mapreduce.cluster.local.dir}/taskTracker/$user/jobcache/$jobid/$taskid/work/tmp
        </span>
        : The temporary directory for the task. 
        (User can specify the property <span class="codefrag">mapreduce.task.tmp.dir</span> to set
        the value of temporary directory for map and reduce tasks. This 
        defaults to <span class="codefrag">./tmp</span>. If the value is not an absolute path,
        it is prepended with task's working directory. Otherwise, it is
        directly assigned. The directory will be created if it doesn't exist.
        Then, the child java tasks are executed with option
        <span class="codefrag">-Djava.io.tmpdir='the absolute path of the tmp dir'</span>.
        Pipes and streaming are set with environment variable,
        <span class="codefrag">TMPDIR='the absolute path of the tmp dir'</span>). This 
        directory is created, if <span class="codefrag">mapreduce.task.tmp.dir</span> has the value
        <span class="codefrag">./tmp</span> 
</li>
        
</ul>
        
</li>
        
</ul>
        
</li>
        
</ul>
<a name="Task+JVM+Reuse"></a>
<h4>Task JVM Reuse</h4>
<p>Jobs can enable task JVMs to be reused by specifying the job 
        configuration <span class="codefrag">mapreduce.job.jvm.numtasks</span>. If the
        value is 1 (the default), then JVMs are not reused 
        (i.e. 1 task per JVM). If it is -1, there is no limit to the number
        of tasks a JVM can run (of the same job). One can also specify some
        value greater than 1 using the api 
        <span class="codefrag">Job.getConfiguration().setInt(Job.JVM_NUM_TASKS_TO_RUN, int)</span>.</p>
<a name="Configured+Parameters"></a>
<h4>Configured Parameters</h4>
<p>The following properties are localized in the job configuration 
         for each task's execution: </p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
          
<tr>
<th colspan="1" rowspan="1">Name</th><th colspan="1" rowspan="1">Type</th><th colspan="1" rowspan="1">Description</th>
</tr>
          
<tr>
<td colspan="1" rowspan="1">mapreduce.job.id</td><td colspan="1" rowspan="1">String</td><td colspan="1" rowspan="1">The job id</td>
</tr>
          
<tr>
<td colspan="1" rowspan="1">mapreduce.job.jar</td><td colspan="1" rowspan="1">String</td>
              <td colspan="1" rowspan="1">job.jar location in job directory</td>
</tr>
          
<tr>
<td colspan="1" rowspan="1">mapreduce.job.local.dir</td><td colspan="1" rowspan="1"> String</td>
              <td colspan="1" rowspan="1"> The job specific shared scratch space</td>
</tr>
          
<tr>
<td colspan="1" rowspan="1">mapreduce.task.id</td><td colspan="1" rowspan="1"> String</td>
              <td colspan="1" rowspan="1"> The task id</td>
</tr>
          
<tr>
<td colspan="1" rowspan="1">mapreduce.task.attempt.id</td><td colspan="1" rowspan="1"> String</td>
              <td colspan="1" rowspan="1"> The task attempt id</td>
</tr>
          
<tr>
<td colspan="1" rowspan="1">mapreduce.task.ismap</td><td colspan="1" rowspan="1"> boolean </td>
              <td colspan="1" rowspan="1">Is this a map task</td>
</tr>
          
<tr>
<td colspan="1" rowspan="1">mapreduce.task.partition</td><td colspan="1" rowspan="1"> int </td>
              <td colspan="1" rowspan="1">The id of the task within the job</td>
</tr>
          
<tr>
<td colspan="1" rowspan="1">mapreduce.map.input.file</td><td colspan="1" rowspan="1"> String</td>
              <td colspan="1" rowspan="1"> The filename that the map is reading from</td>
</tr>
          
<tr>
<td colspan="1" rowspan="1">mapreduce.map.input.start</td><td colspan="1" rowspan="1"> long</td>
              <td colspan="1" rowspan="1"> The offset of the start of the map input split</td>
</tr>
          
<tr>
<td colspan="1" rowspan="1">mapreduce.map.input.length </td><td colspan="1" rowspan="1">long </td>
              <td colspan="1" rowspan="1">The number of bytes in the map input split</td>
</tr>
          
<tr>
<td colspan="1" rowspan="1">mapreduce.task.output.dir</td><td colspan="1" rowspan="1"> String </td>
              <td colspan="1" rowspan="1">The task's temporary output directory</td>
</tr>
        
</table>
<p>
        
<strong>Note:</strong>
        During the execution of a streaming job, the names of the "mapred" parameters are transformed. 
        The dots ( . ) become underscores ( _ ).
        For example, mapreduce.job.id becomes mapreduce.job.id and mapreduce.job.jar becomes mapreduce.job.jar. 
        To get the values in a streaming job's mapper/reducer use the parameter names with the underscores.
        </p>
<a name="Task+Logs"></a>
<h4>Task Logs</h4>
<p>The standard output (stdout) and error (stderr) streams of the task 
        are read by the TaskTracker and logged to 
        <span class="codefrag">${HADOOP_LOG_DIR}/userlogs</span>
</p>
<a name="Distributing+Libraries"></a>
<h4>Distributing Libraries</h4>
<p>The <a href="#DistributedCache">DistributedCache</a> can also be used
        to distribute both jars and native libraries for use in the map 
        and/or reduce tasks. The child-jvm always has its 
        <em>current working directory</em> added to the
        <span class="codefrag">java.library.path</span> and <span class="codefrag">LD_LIBRARY_PATH</span>. 
        And hence the cached libraries can be loaded via 
        <a href="http://java.sun.com/javase/6/docs/api/java/lang/System.html#loadLibrary(java.lang.String)">
        System.loadLibrary</a> or 
        <a href="http://java.sun.com/javase/6/docs/api/java/lang/System.html#load(java.lang.String)">
        System.load</a>. More details on how to load shared libraries through 
        distributed cache are documented under 
        <a href="http://hadoop.apache.org/common/docs/current/native_libraries.html#Loading+Native+Libraries+Through+DistributedCache">
        Building Native Hadoop Libraries</a>.</p>
<a name="Job+Credentials"></a>
<h4>Job Credentials</h4>
<p>In a secure cluster, the user is authenticated via Kerberos'
             kinit command. Because of scalability concerns, we don't push
             the client's Kerberos' tickets in MapReduce jobs. Instead, we
             acquire delegation tokens from each HDFS NameNode that the job
             will use and store them in the job as part of job submission.
             The delegation tokens are automatically obtained
             for the HDFS that holds the staging directories, where the
             job files are written, and any HDFS systems referenced by
             FileInputFormats, FileOutputFormats, DistCp, and the
             distributed cache.
             Other applications require to set the configuration
             "mapreduce.job.hdfs-servers" for all NameNodes that tasks might 
             need to talk during the job execution. This is a comma separated
             list of file system names, such as "hdfs://nn1/,hdfs://nn2/".
             These tokens are passed to the JobTracker
             as part of the job submission as <a href="http://hadoop.apache.org/common/docs/current/api/org/apache/hadoop/security/Credentials.html">Credentials</a>. </p>
<p>Similar to HDFS delegation tokens, we also have MapReduce delegation tokens. The
             MapReduce tokens are provided so that tasks can spawn jobs if they wish to. The tasks authenticate
             to the JobTracker via the MapReduce delegation tokens. The delegation token can
             be obtained via the API in <a href="api/org/apache/hadoop/mapred/jobclient/getdelegationtoken">
             JobClient.getDelegationToken</a>. The obtained token must then be pushed onto the
             credentials that is there in the JobConf used for job submission. The API  
             <a href="http://hadoop.apache.org/common/docs/current/api/org/apache/hadoop/security/Credentials.html#addToken(org.apache.hadoop.io.Text, org.apache.hadoop.security.token.Token)">Credentials.addToken</a>
             can be used for this. </p>
<p>The credentials are sent to the JobTracker as part of the job submission process.
             The JobTracker persists the tokens and secrets in its filesystem (typically HDFS) 
             in a file within mapred.system.dir/JOBID. The TaskTracker localizes the file as part
             job localization. Tasks see an environment variable called
             HADOOP_TOKEN_FILE_LOCATION and the framework sets this to point to the
             localized file. In order to launch jobs from tasks or for doing any HDFS operation,
             tasks must set the configuration "mapreduce.job.credentials.binary" to point to
             this token file.</p>
<p>The HDFS delegation tokens passed to the JobTracker during job submission are
             are cancelled by the JobTracker when the job completes. This is the default behavior
             unless mapreduce.job.complete.cancel.delegation.tokens is set to false in the 
             JobConf. For jobs whose tasks in turn spawns jobs, this should be set to false.
             Applications sharing JobConf objects between multiple jobs on the JobClient side 
             should look at setting mapreduce.job.complete.cancel.delegation.tokens to false. 
             This is because the Credentials object within the JobConf will then be shared. 
             All jobs will end up sharing the same tokens, and hence the tokens should not be 
             canceled when the jobs in the sequence finish.</p>
<p>Apart from the HDFS delegation tokens, arbitrary secrets can also be 
             passed during the job submission for tasks to access other third party services.
             The APIs 
             <a href="api/org/apache/hadoop/mapred/JobConf.html#getCredentials()">
             JobConf.getCredentials</a> or <a href="api/org/apache/hadoop/mapreduce/JobContext.html#getcredentials">JobContext.getCredentials()</a>
             should be used to get the credentials object and then
             <a href="http://hadoop.apache.org/common/docs/current/api/org/apache/hadoop/security/Credentials.html#addSecretKey(org.apache.hadoop.io.Text, byte[])">
             Credentials.addSecretKey</a> should be used to add secrets.</p>
<p>For applications written using the old MapReduce API, the Mapper/Reducer classes 
             need to implement <a href="api/org/apache/hadoop/mapred/jobconfigurable">
             JobConfigurable</a> in order to get access to the credentials in the tasks.
             A reference to the JobConf passed in the 
             <a href="api/org/apache/hadoop/mapred/jobconfigurable/configure">
             JobConfigurable.configure</a> should be stored. In the new MapReduce API, 
             a similar thing can be done in the 
             <a href="api/org/apache/hadoop/mapreduce/mapper/setup">Mapper.setup</a>
             method.
             The api <a href="api/org/apache/hadoop/mapred/JobConf.html#getCredentials()">
              JobConf.getCredentials()</a> or the api <a href="api/org/apache/hadoop/mapreduce/JobContext.html#getcredentials">JobContext.getCredentials()</a>
              should be used to get the credentials reference (depending
              on whether the new MapReduce API or the old MapReduce API is used). 
              Tasks can access the secrets using the APIs in <a href="http://hadoop.apache.org/common/docs/current/api/org/apache/hadoop/security/Credentials.html">Credentials</a> 
</p>
<a name="Job+Submission+and+Monitoring"></a>
<h3 class="h4">Job Submission and Monitoring</h3>
<p>The <span class="codefrag">Job</span>
        is the primary interface by which user-job interacts
        with the <span class="codefrag">JobTracker</span>.</p>
<p>
<span class="codefrag">Job</span> provides facilities to submit jobs, track their 
        progress, access component-tasks' reports and logs, get the MapReduce 
        cluster's status information and so on.</p>
<p>The job submission process involves:</p>
<ol>
          
<li>Checking the input and output specifications of the job.</li>
          
<li>Computing the <span class="codefrag">InputSplit</span> values for the job.</li>
          
<li>
            Setting up the requisite accounting information for the 
            <span class="codefrag">DistributedCache</span> of the job, if necessary.
          </li>
          
<li>
            Copying the job's jar and configuration to the MapReduce system 
            directory on the <span class="codefrag">FileSystem</span>.
          </li>
          
<li>
            Submitting the job to the <span class="codefrag">JobTracker</span> and optionally 
            monitoring it's status.
          </li>
        
</ol>
<p> User can view the history log summary for a given history file
        using the following command <br>
        
<span class="codefrag">$ bin/hadoop job -history history-file</span>
<br> 
        This command will print job details, failed and killed tip
        details. <br>
        More details about the job such as successful tasks and 
        task attempts made for each task can be viewed using the  
        following command <br>
       
<span class="codefrag">$ bin/hadoop job -history all history-file</span>
<br>
</p>
<p> User can use 
        <a href="api/org/apache/hadoop/mapred/OutputLogFilter.html">OutputLogFilter</a>
        to filter log files from the output directory listing. </p>
<p>Normally the user creates the application, describes various facets 
        of the job via <span class="codefrag">Job</span>, and then uses the 
        <span class="codefrag">waitForCompletion()</span> method to submit the job and monitor its progress.</p>
<a name="Job+Control"></a>
<h4>Job Control</h4>
<p>Users may need to chain MapReduce jobs to accomplish complex
          tasks which cannot be done via a single MapReduce job. This is fairly
          easy since the output of the job typically goes to distributed 
          file-system, and the output, in turn, can be used as the input for the 
          next job.</p>
<p>However, this also means that the onus on ensuring jobs are 
          complete (success/failure) lies squarely on the clients. In such 
          cases, the various job-control options are:</p>
<ul>
            
<li>
<a href="api/org/apache/hadoop/mapreduce/Job.html#waitForCompletion(boolean)"><span class="codefrag">Job.waitForCompletion()</span></a> :
              Submits the job and returns only after the 
              job has completed.
            </li>
            
<li>
              
<a href="api/org/apache/hadoop/mapreduce/Job.html#submit()"><span class="codefrag">Job.submit()</span></a> : Only submits the job;, then poll the
              other methods of <span class="codefrag">Job</span> such as <span class="codefrag">isComplete()</span>,
              <span class="codefrag">isSuccessful()</span>, etc.
              to query status and make scheduling decisions.
            </li>
            
<li>
              
<span class="codefrag">Job.getConfiguration().set(Job.END_NOTIFICATION_URL, String)</span>
              : Sets up a notification upon job-completion, thus avoiding polling.
            </li>
          
</ul>
<a name="Job+Authorization"></a>
<h4>Job Authorization</h4>
<p>Job level authorization and queue level authorization are enabled
          on the cluster, if the configuration
          <span class="codefrag">mapreduce.cluster.acls.enabled</span> is set to
          true. When enabled, access control checks are done by (a) the
          JobTracker before allowing users to submit jobs to queues and
          administering these jobs and (b) by the JobTracker and the TaskTracker
          before allowing users to view job details or to modify a job using
          MapReduce APIs, CLI or web user interfaces.</p>
<p>A job submitter can specify access control lists for viewing or
          modifying a job via the configuration properties
          <span class="codefrag">mapreduce.job.acl-view-job</span> and
          <span class="codefrag">mapreduce.job.acl-modify-job</span> respectively. By default, 
          nobody is given access in these properties.</p>
<p>However, irrespective of the job ACLs configured, a job's owner,
          the user who started the cluster and cluster administrators
          (<span class="codefrag">mapreduce.cluster.administrators</span>)
          and queue administrators of the queue to which the job was submitted
          to (<span class="codefrag">acl-administer-jobs</span>) always have access to view and
          modify a job.</p>
<p> A job view ACL authorizes users against the configured 
          <span class="codefrag">mapreduce.job.acl-view-job</span> before returning possibly 
          sensitive information about a job, like: </p>
<ul>
            
<li> job level counters </li>
            
<li> task level counters </li>
            
<li> tasks's diagnostic information </li>
            
<li> task logs displayed on the TaskTracker web UI </li>
            
<li> job.xml showed by the JobTracker's web UI </li>
          
</ul>
<p>Other information about a job, like its status and its profile, 
          is accessible to all users, without requiring authorization.</p>
<p> A job modification ACL authorizes users against the configured
          <span class="codefrag">mapreduce.job.acl-modify-job</span> before allowing
          modifications to jobs, like: </p>
<ul>
            
<li> killing a job </li>
            
<li> killing/failing a task of a job </li>
            
<li> setting the priority of a job </li>
          
</ul>
<p>These view and modify operations on jobs are also permitted by
          the queue level ACL, "acl-administer-jobs", configured via
          mapred-queue-acls.xml. The caller will be able to do the operation
          if he/she is part of either queue admins ACL or job modification ACL
          or the user who started the cluster or a cluster administrator
          (<span class="codefrag">mapreduce.cluster.administrators</span>).
          </p>
<p>The format of a job level ACL is the same as the format for a
          queue level ACL as defined in the
          <a href="http://hadoop.apache.org/common/docs/current/cluster_setup.html#Configuring+the+Hadoop+Daemons">
          Cluster Setup</a> documentation.
          </p>
<a name="Job+Input"></a>
<h3 class="h4">Job Input</h3>
<p>
<a href="api/org/apache/hadoop/mapreduce/InputFormat.html">
        InputFormat</a> describes the input-specification for a MapReduce job.
        </p>
<p>The MapReduce framework relies on the <span class="codefrag">InputFormat</span> of 
        the job to:</p>
<ol>
          
<li>Validate the input-specification of the job.</li>
          
<li>
            Split-up the input file(s) into logical <span class="codefrag">InputSplit</span> 
            instances, each of which is then assigned to an individual 
            <span class="codefrag">Mapper</span>.
          </li>
          
<li>
            Provide the <span class="codefrag">RecordReader</span> implementation used to
            glean input records from the logical <span class="codefrag">InputSplit</span> for 
            processing by the <span class="codefrag">Mapper</span>.
          </li>
        
</ol>
<p>The default behavior of file-based <span class="codefrag">InputFormat</span>
        implementations, typically sub-classes of 
        <a href="api/org/apache/hadoop/mapreduce/lib/input/FileInputFormat.html">
        FileInputFormat</a>, is to split the input into <em>logical</em> 
        <span class="codefrag">InputSplit</span> instances based on the total size, in bytes, of 
        the input files. However, the <span class="codefrag">FileSystem</span> blocksize of the 
        input files is treated as an upper bound for input splits. A lower bound
        on the split size can be set via <span class="codefrag">mapreduce.input.fileinputformat.split.minsize</span>.</p>
<p>Clearly, logical splits based on input-size is insufficient for many
        applications since record boundaries must be respected. In such cases, 
        the application should implement a <span class="codefrag">RecordReader</span>, who is 
        responsible for respecting record-boundaries and presents a 
        record-oriented view of the logical <span class="codefrag">InputSplit</span> to the 
        individual task.</p>
<p>
<a href="api/org/apache/hadoop/mapreduce/lib/input/TextInputFormat.html">
        TextInputFormat</a> is the default <span class="codefrag">InputFormat</span>.</p>
<p>If <span class="codefrag">TextInputFormat</span> is the <span class="codefrag">InputFormat</span> for a 
        given job, the framework detects input-files with the <em>.gz</em>
        extensions and automatically decompresses them using the 
        appropriate <span class="codefrag">CompressionCodec</span>. However, it must be noted that
        compressed files with the above extensions cannot be <em>split</em> and 
        each compressed file is processed in its entirety by a single mapper.</p>
<a name="InputSplit"></a>
<h4>InputSplit</h4>
<p>
<a href="api/org/apache/hadoop/mapreduce/InputSplit.html">
          InputSplit</a> represents the data to be processed by an individual 
          <span class="codefrag">Mapper</span>.</p>
<p>Typically <span class="codefrag">InputSplit</span> presents a byte-oriented view of
          the input, and it is the responsibility of <span class="codefrag">RecordReader</span>
          to process and present a record-oriented view.</p>
<p>
<a href="api/org/apache/hadoop/mapreduce/lib/input/FileSplit.html">
          FileSplit</a> is the default <span class="codefrag">InputSplit</span>. It sets 
          <span class="codefrag">mapreduce.map.input.file</span> to the path of the input file for the
          logical split.</p>
<a name="RecordReader"></a>
<h4>RecordReader</h4>
<p>
<a href="api/org/apache/hadoop/mapreduce/RecordReader.html">
          RecordReader</a> reads <span class="codefrag">&lt;key, value&gt;</span> pairs from an 
          <span class="codefrag">InputSplit</span>.</p>
<p>Typically the <span class="codefrag">RecordReader</span> converts the byte-oriented 
          view of the input, provided by the <span class="codefrag">InputSplit</span>, and 
          presents a record-oriented to the <span class="codefrag">Mapper</span> implementations 
          for processing. <span class="codefrag">RecordReader</span> thus assumes the 
          responsibility of processing record boundaries and presents the tasks 
          with keys and values.</p>
<a name="Job+Output"></a>
<h3 class="h4">Job Output</h3>
<p>
<a href="api/org/apache/hadoop/mapreduce/OutputFormat.html">
        OutputFormat</a> describes the output-specification for a MapReduce 
        job.</p>
<p>The MapReduce framework relies on the <span class="codefrag">OutputFormat</span> of 
        the job to:</p>
<ol>
          
<li>
            Validate the output-specification of the job; for example, check that 
            the output directory doesn't already exist.
          </li>
          
<li>
            Provide the <span class="codefrag">RecordWriter</span> implementation used to 
            write the output files of the job. Output files are stored in a 
            <span class="codefrag">FileSystem</span>.
          </li>
        
</ol>
<p>
<span class="codefrag">TextOutputFormat</span> is the default 
        <span class="codefrag">OutputFormat</span>.</p>
<a name="Lazy+Output+Creation"></a>
<h4>Lazy Output Creation</h4>
<p>It is possible to delay creation of output until the first write attempt 
           by using <a href="api/org/apache/hadoop/mapreduce/lib/output/LazyOutputFormat.html">
           LazyOutputFormat</a>. This is particularly useful in preventing the 
           creation of zero byte files when there is no call to output.collect 
           (or Context.write). This is achieved by calling the static method 
           <span class="codefrag">setOutputFormatClass</span> of <span class="codefrag">LazyOutputFormat</span> 
           with the intended <span class="codefrag">OutputFormat</span> as the argument. The following example 
           shows how to delay creation of files when using the <span class="codefrag">TextOutputFormat</span>
        
</p>
<p>
        
<span class="codefrag">import org.apache.hadoop.mapreduce.lib.output.LazyOutputFormat;</span> 
<br>
        
<span class="codefrag">LazyOutputFormat.setOutputFormatClass(job, TextOutputFormat.class);</span>
        
</p>
<a name="OutputCommitter"></a>
<h4>OutputCommitter</h4>
<p>
<a href="api/org/apache/hadoop/mapreduce/OutputCommitter.html">
        OutputCommitter</a> describes the commit of task output for a 
        MapReduce job.</p>
<p>The MapReduce framework relies on the <span class="codefrag">OutputCommitter</span>
        of the job to:</p>
<ol>
          
<li>
            Setup the job during initialization. For example, create
            the temporary output directory for the job during the
            initialization of the job. 
            Job setup is done by a separate task when the job is
            in PREP state and after initializing tasks. Once the setup task
            completes, the job will be moved to RUNNING state.
          </li>
          
<li>
            Cleanup the job after the job completion. For example, remove the
            temporary output directory after the job completion.
            Job cleanup is done by a separate task at the end of the job.
            Job is declared SUCCEDED/FAILED/KILLED after the cleanup
            task completes.
          </li>
          
<li>
            Setup the task temporary output.
            Task setup is done as part of the same task, during task initialization.
          </li> 
          
<li>
            Check whether a task needs a commit. This is to avoid the commit
            procedure if a task does not need commit.
          </li>
          
<li>
            Commit of the task output. 
            Once task is done, the task will commit it's output if required.  
          </li> 
          
<li>
            Discard the task commit.
            If the task has been failed/killed, the output will be cleaned-up. 
            If task could not cleanup (in exception block), a separate task 
            will be launched with same attempt-id to do the cleanup.
          </li>
        
</ol>
<p>
<a href="api/org/apache/hadoop/mapreduce/lib/output/FileOutputCommitter.html"><span class="codefrag">FileOutputCommitter</span></a>
        is the default 
        <span class="codefrag">OutputCommitter</span>. Job setup/cleanup tasks occupy 
        map or reduce slots, whichever is free on the TaskTracker. And
        JobCleanup task, TaskCleanup tasks and JobSetup task have the highest
        priority, and in that order.</p>
<a name="Task+Side-Effect+Files"></a>
<h4>Task Side-Effect Files</h4>
<p>In some applications, component tasks need to create and/or write to
          side-files, which differ from the actual job-output files.</p>
<p>In such cases there could be issues with two instances of the same 
          <span class="codefrag">Mapper</span> or <span class="codefrag">Reducer</span> running simultaneously (for
          example, speculative tasks) trying to open and/or write to the same 
          file (path) on the <span class="codefrag">FileSystem</span>. Hence the 
          application-writer will have to pick unique names per task-attempt 
          (using the attemptid, say <span class="codefrag">attempt_200709221812_0001_m_000000_0</span>), 
          not just per task.</p>
<p>To avoid these issues the MapReduce framework, when the 
          <span class="codefrag">OutputCommitter</span> is <span class="codefrag">FileOutputCommitter</span>, 
          maintains a special 
          <span class="codefrag">${mapreduce.output.fileoutputformat.outputdir}/_temporary/_${taskid}</span>
          sub-directory
          accessible via <span class="codefrag">${mapreduce.task.output.dir}</span>
          for each task-attempt on the <span class="codefrag">FileSystem</span> where the output
          of the task-attempt is stored. On successful completion of the 
          task-attempt, the files in the 
          <span class="codefrag">${mapreduce.output.fileoutputformat.outputdir}/_temporary/_${taskid}</span>
          (only) are <em>promoted</em> to
          <span class="codefrag">${mapreduce.output.fileoutputformat.outputdir}</span>. Of course, 
          the framework discards the sub-directory of unsuccessful task-attempts. 
          This process is completely transparent to the application.</p>
<p>The application-writer can take advantage of this feature by 
          creating any side-files required in <span class="codefrag">${mapreduce.task.output.dir}</span>
          during execution of a task via 
          <a href="api/org/apache/hadoop/mapreduce/lib/output/FileOutputFormat.html#getWorkOutputPath(org.apache.hadoop.mapreduce.TaskInputOutputContext)">
          FileOutputFormat.getWorkOutputPath()</a>, and the framework will promote them 
          similarly for succesful task-attempts, thus eliminating the need to 
          pick unique paths per task-attempt.</p>
<p>Note: The value of <span class="codefrag">${mapreduce.task.output.dir}</span> during 
          execution of a particular task-attempt is actually 
          <span class="codefrag">${mapreduce.output.fileoutputformat.outputdir}/_temporary/_{$taskid}</span>, and this value is 
          set by the MapReduce framework. So, just create any side-files in the 
          path  returned by
          <a href="api/org/apache/hadoop/mapreduce/lib/output/FileOutputFormat.html#getWorkOutputPath(org.apache.hadoop.mapreduce.TaskInputOutputContext)">
          FileOutputFormat.getWorkOutputPath() </a>from MapReduce 
          task to take advantage of this feature.</p>
<p>The entire discussion holds true for maps of jobs with 
           reducer=NONE (i.e. 0 reduces) since output of the map, in that case, 
           goes directly to HDFS.</p>
<a name="RecordWriter"></a>
<h4>RecordWriter</h4>
<p>
<a href="api/org/apache/hadoop/mapreduce/RecordWriter.html">
          RecordWriter</a> writes the output <span class="codefrag">&lt;key, value&gt;</span> 
          pairs to an output file.</p>
<p>RecordWriter implementations write the job outputs to the 
          <span class="codefrag">FileSystem</span>.</p>
<a name="Other+Useful+Features"></a>
<h3 class="h4">Other Useful Features</h3>
<a name="Submitting+Jobs+to+Queues"></a>
<h4>Submitting Jobs to Queues</h4>
<p>Users submit jobs to Queues. Queues, as collection of jobs, 
          allow the system to provide specific functionality. For example, 
          queues use ACLs to control which users 
          who can submit jobs to them. Queues are expected to be primarily 
          used by Hadoop Schedulers. </p>
<p>Hadoop comes configured with a single mandatory queue, called 
          'default'. Queue names are defined in the 
          <span class="codefrag">mapred.queue.names</span> property of the Hadoop site
          configuration. Some job schedulers, such as the 
          <a href="capacity_scheduler.html">Capacity Scheduler</a>, 
          support multiple queues.</p>
<p>A job defines the queue it needs to be submitted to through the
          <span class="codefrag">mapreduce.job.queuename</span> property.
          Setting the queue name is optional. If a job is submitted 
          without an associated queue name, it is submitted to the 'default' 
          queue.</p>
<a name="Counters"></a>
<h4>Counters</h4>
<p>
<a href="api/org/apache/hadoop/mapreduce/Counters.html"><span class="codefrag">Counters</span></a> represent global counters, defined either by 
          the MapReduce framework or applications. Each <a href="api/org/apache/hadoop/mapreduce/Counter.html"><span class="codefrag">Counter</span></a> can 
          be of any <span class="codefrag">Enum</span> type. Counters of a particular 
          <span class="codefrag">Enum</span> are bunched into groups of type 
          <span class="codefrag">Counters.Group</span>.</p>
<p>Applications can define arbitrary <span class="codefrag">Counters</span> (of type 
          <span class="codefrag">Enum</span>); get a <span class="codefrag">Counter</span> object from the task's
          Context with the <a href="api/org/apache/hadoop/mapreduce/TaskInputOutputContext.html#getCounter(java.lang.Enum)"><span class="codefrag">getCounter()</span></a> method, and then call
          the <a href="api/org/apache/hadoop/mapreduce/Counter.html#increment(long)"><span class="codefrag">Counter.increment(long)</span></a> method to increment its
          value locally. These counters are then globally aggregated by the framework.</p>
<a name="DistributedCache"></a>
<h4>DistributedCache</h4>
<p>
<a href="api/org/apache/hadoop/filecache/DistributedCache.html">
          DistributedCache</a> distributes application-specific, large, read-only 
          files efficiently.</p>
<p>
<span class="codefrag">DistributedCache</span> is a facility provided by the 
          MapReduce framework to cache files (text, archives, jars and so on) 
          needed by applications.</p>
<p>Applications specify the files to be cached via urls (hdfs://)
          in the <span class="codefrag">Job</span>. The <span class="codefrag">DistributedCache</span> 
          assumes that the files specified via hdfs:// urls are already present 
          on the <span class="codefrag">FileSystem</span>.</p>
<p>The framework will copy the necessary files to the slave node 
          before any tasks for the job are executed on that node. Its 
          efficiency stems from the fact that the files are only copied once 
          per job and the ability to cache archives which are un-archived on 
          the slaves.</p>
<p>
<span class="codefrag">DistributedCache</span> tracks the modification timestamps of 
          the cached files. Clearly the cache files should not be modified by 
          the application or externally while the job is executing.</p>
<p>
<span class="codefrag">DistributedCache</span> can be used to distribute simple, 
          read-only data/text files and more complex types such as archives and
          jars. Archives (zip, tar, tgz and tar.gz files) are 
          <em>un-archived</em> at the slave nodes. Files 
          have <em>execution permissions</em> set. </p>
<p>The files/archives can be distributed by setting the property
          <span class="codefrag">mapred.cache.{files|archives}</span>. If more than one 
          file/archive has to be distributed, they can be added as comma
          separated paths. The properties can also be set by APIs 
          <a href="api/org/apache/hadoop/filecache/DistributedCache.html#addCacheFile(java.net.URI,%20org.apache.hadoop.conf.Configuration)">
          DistributedCache.addCacheFile(URI,conf)</a>/ 
          <a href="api/org/apache/hadoop/filecache/DistributedCache.html#addCacheArchive(java.net.URI,%20org.apache.hadoop.conf.Configuration)">
          DistributedCache.addCacheArchive(URI,conf)</a> and
          <a href="api/org/apache/hadoop/filecache/DistributedCache.html#setCacheFiles(java.net.URI[],%20org.apache.hadoop.conf.Configuration)">
          DistributedCache.setCacheFiles(URIs,conf)</a>/
          <a href="api/org/apache/hadoop/filecache/DistributedCache.html#setCacheArchives(java.net.URI[],%20org.apache.hadoop.conf.Configuration)">
          DistributedCache.setCacheArchives(URIs,conf)</a> 
          where URI is of the form
          <span class="codefrag">hdfs://host:port/absolute-path#link-name</span>.
          In Streaming, the files can be distributed through command line
          option <span class="codefrag">-cacheFile/-cacheArchive</span>.</p>
<p>Optionally users can also direct the <span class="codefrag">DistributedCache</span>
          to <em>symlink</em> the cached file(s) into the <span class="codefrag">current working 
          directory</span> of the task via the 
          <a href="api/org/apache/hadoop/filecache/DistributedCache.html#createSymlink(org.apache.hadoop.conf.Configuration)">
          DistributedCache.createSymlink(Configuration)</a> api. Or by setting
          the configuration property <span class="codefrag">mapreduce.job.cache.symlink.create</span>
          as <span class="codefrag">yes</span>. The DistributedCache will use the 
          <span class="codefrag">fragment</span> of the URI as the name of the symlink. 
          For example, the URI 
          <span class="codefrag">hdfs://namenode:port/lib.so.1#lib.so</span>
          will have the symlink name as <span class="codefrag">lib.so</span> in task's cwd
          for the file <span class="codefrag">lib.so.1</span> in distributed cache.</p>
<p>The <span class="codefrag">DistributedCache</span> can also be used as a 
          rudimentary software distribution mechanism for use in the
          map and/or reduce tasks. It can be used to distribute both
          jars and native libraries. The 
          <a href="api/org/apache/hadoop/filecache/DistributedCache.html#addArchiveToClassPath(org.apache.hadoop.fs.Path,%20org.apache.hadoop.conf.Configuration)">
          DistributedCache.addArchiveToClassPath(Path, Configuration)</a> or 
          <a href="api/org/apache/hadoop/filecache/DistributedCache.html#addFileToClassPath(org.apache.hadoop.fs.Path,%20org.apache.hadoop.conf.Configuration)">
          DistributedCache.addFileToClassPath(Path, Configuration)</a> api 
          can be used to cache files/jars and also add them to the 
          <em>classpath</em> of child-jvm. The same can be done by setting
          the configuration properties 
          <span class="codefrag">mapreduce.job.classpath.{files|archives}</span>. Similarly the
          cached files that are symlinked into the working directory of the
          task can be used to distribute native libraries and load them.</p>
<a name="Private+and+Public+DistributedCache+Files"></a>
<h5>Private and Public DistributedCache Files</h5>
<p>DistributedCache files can be private or public, that
               determines how they can be shared on the slave nodes.</p>
<ul>
              
<li>"Private" DistributedCache files are cached in a local
              directory private to the user whose jobs need these
              files. These files are shared by all
              tasks and jobs of the specific user only and cannot be accessed by
              jobs of other users on the slaves. A DistributedCache file becomes
              private by virtue of its permissions on the file system where the
              files are uploaded, typically HDFS. If the file has no
              world readable access, or if the directory path leading to the
              file has no world executable access for lookup, then the file
              becomes private.
              </li>
              
<li>"Public" DistributedCache files are cached in a global
              directory and the file access is setup such that they are
              publicly visible to all users. These files can be shared by
              tasks and jobs of all users on the slaves.
              A DistributedCache file becomes public by virtue of its permissions
              on the file system where the files are uploaded, typically HDFS.
              If the file has world readable access, AND if the directory
              path leading to the file has world executable access for lookup,
              then the file becomes public. In other words, if the user intends
              to make a file publicly available to all users, the file permissions
              must be set to be world readable, and the directory permissions
              on the path leading to the file must be world executable.
            </li>
            
</ul>
<p>The <span class="codefrag">DistributedCache</span> tracks modification timestamps 
          of the cache files/archives. Clearly the cache files/archives should
          not be modified by the application or externally 
          while the job is executing.</p>
<p>Here is an illustrative example on how to use the 
          <span class="codefrag">DistributedCache</span>:<br>
           // Setting up the cache for the application
           1. Copy the requisite files to the <span class="codefrag">FileSystem</span>:<br>
            
<span class="codefrag">$ bin/hadoop fs -copyFromLocal lookup.dat /myapp/lookup.dat</span>
<br>  
            
<span class="codefrag">$ bin/hadoop fs -copyFromLocal map.zip /myapp/map.zip </span>
<br> 
            
<span class="codefrag">$ bin/hadoop fs -copyFromLocal mylib.jar /myapp/mylib.jar</span>
<br>
            
<span class="codefrag">$ bin/hadoop fs -copyFromLocal mytar.tar /myapp/mytar.tar</span>
<br>
            
<span class="codefrag">$ bin/hadoop fs -copyFromLocal mytgz.tgz /myapp/mytgz.tgz</span>
<br>
            
<span class="codefrag">$ bin/hadoop fs -copyFromLocal mytargz.tar.gz /myapp/mytargz.tar.gz</span>
<br>
           2. Setup the job<br>
            
<span class="codefrag">Job job = new Job(conf);</span>
<br>
            
<span class="codefrag">job.addCacheFile(new URI("/myapp/lookup.dat#lookup.dat"));</span>
<br>
            
<span class="codefrag">job.addCacheArchive(new URI("/myapp/map.zip"));</span>
<br>
            
<span class="codefrag">job.addFileToClassPath(new Path("/myapp/mylib.jar"));</span>
<br>
            
<span class="codefrag">job.addCacheArchive(new URI("/myapp/mytar.tar"));</span>
<br>
            
<span class="codefrag">job.addCacheArchive(new URI("/myapp/mytgz.tgz"));</span>
<br>
            
<span class="codefrag">job.addCacheArchive(new URI("/myapp/mytargz.tar.gz"));</span>
<br>
      
           3. Use the cached files in the 
              <span class="codefrag">{@link org.apache.hadoop.mapreduce.Mapper}
              or {@link org.apache.hadoop.mapreduce.Reducer}:</span>
<br>
      
              
<span class="codefrag">public static class MapClass extends Mapper&lt;K, V, K, V&gt; {</span>
<br>
                
<span class="codefrag">&nbsp;&nbsp;private Path[] localArchives;</span>
<br>
                
<span class="codefrag">&nbsp;&nbsp;private Path[] localFiles;</span>
<br>
                
<span class="codefrag">&nbsp;&nbsp;public void setup(Context context) {</span>
<br>
                 
<span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;// Get the cached archives/files</span>
<br>
                 
<span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;localArchives = context.getLocalCacheArchives();</span>
<br>
                 
<span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;localFiles = context.getLocalCacheFiles();</span>
<br>
              
<span class="codefrag">&nbsp;&nbsp;}</span>
<br>
        
              
<span class="codefrag">&nbsp;&nbsp;public void map(K key, V value, 
                  Context context) throws IOException {</span>
<br>
                
<span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;// Use data from the cached archives/files here</span>
<br>
                
<span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;// ...</span>
<br>
                
<span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;// ...</span>
<br>
                
<span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;context.write(k, v);</span>
<br>
              
<span class="codefrag">&nbsp;&nbsp;}</span>
<br>
            
<span class="codefrag">}</span>
</p>
<a name="Tool"></a>
<h4>Tool</h4>
<p>The <a href="api/org/apache/hadoop/util/Tool.html">Tool</a> 
          interface supports the handling of generic Hadoop command-line options.
          </p>
<p>
<span class="codefrag">Tool</span> is the standard for any MapReduce tool or 
          application. The application should delegate the handling of 
          standard command-line options to 
          <a href="api/org/apache/hadoop/util/GenericOptionsParser.html">
          GenericOptionsParser</a> via          
          <a href="api/org/apache/hadoop/util/ToolRunner.html#run(org.apache.hadoop.util.Tool, java.lang.String[])">
          ToolRunner.run(Tool, String[])</a> and only handle its custom 
          arguments.</p>
<p>
            The generic Hadoop command-line options are:<br>
            
<span class="codefrag">
              -conf &lt;configuration file&gt;
            </span>
            
<br>
            
<span class="codefrag">
              -D &lt;property=value&gt;
            </span>
            
<br>
            
<span class="codefrag">
              -fs &lt;local|namenode:port&gt;
            </span>
            
<br>
            
<span class="codefrag">
              -jt &lt;local|jobtracker:port&gt;
            </span>
          
</p>
<a name="IsolationRunner"></a>
<h4>IsolationRunner</h4>
<p>
<a href="api/org/apache/hadoop/mapred/IsolationRunner.html">
          IsolationRunner</a> is a utility to help debug MapReduce programs.</p>
<p>To use the <span class="codefrag">IsolationRunner</span>, first set 
          <span class="codefrag">keep.failed.tasks.files</span> to <span class="codefrag">true</span> 
          (also see <span class="codefrag">keep.tasks.files.pattern</span>).</p>
<p>
            Next, go to the node on which the failed task ran and go to the 
            <span class="codefrag">TaskTracker</span>'s local directory and run the 
            <span class="codefrag">IsolationRunner</span>:<br>
            
<span class="codefrag">$ cd &lt;local path&gt;
            /taskTracker/$user/jobcache/$jobid/${taskid}/work</span>
<br>
            
<span class="codefrag">
              $ bin/hadoop org.apache.hadoop.mapred.IsolationRunner ../job.xml
            </span>
          
</p>
<p>
<span class="codefrag">IsolationRunner</span> will run the failed task in a single 
          jvm, which can be in the debugger, over precisely the same input.</p>
<a name="Profiling"></a>
<h4>Profiling</h4>
<p>Profiling is a utility to get a representative (2 or 3) sample
          of built-in java profiler for a sample of maps and reduces. </p>
<p>User can specify whether the system should collect profiler
          information for some of the tasks in the job by setting the
          configuration property <span class="codefrag">mapreduce.task.profile</span>. The
          value can be set using the api 
          <a href="api/org/apache/hadoop/mapreduce/Job.html#setProfileEnabled(boolean)">
          Job.setProfileEnabled(boolean)</a>. If the value is set 
          <span class="codefrag">true</span>, the task profiling is enabled. The profiler
          information is stored in the user log directory. By default, 
          profiling is not enabled for the job.  </p>
<p>Once user configures that profiling is needed, she/he can use
          the configuration property 
          <span class="codefrag">mapreduce.task.profile.{maps|reduces}</span> to set the ranges
          of MapReduce tasks to profile. The value can be set using the api 
          <a href="api/org/apache/hadoop/mapreduce/Job.html#setProfileTaskRange(boolean,%20java.lang.String)">
          Job.setProfileTaskRange(boolean,String)</a>.
          By default, the specified range is <span class="codefrag">0-2</span>.</p>
<p>User can also specify the profiler configuration arguments by 
          setting the configuration property 
          <span class="codefrag">mapreduce.task.profile.params</span>. The value can be specified 
          using the api
          <a href="api/org/apache/hadoop/mapreduce/Job.html#setProfileParams(java.lang.String)">
          Job.setProfileParams(String)</a>. If the string contains a 
          <span class="codefrag">%s</span>, it will be replaced with the name of the profiling
          output file when the task runs. These parameters are passed to the
          task child JVM on the command line. The default value for 
          the profiling parameters is 
          <span class="codefrag">-agentlib:hprof=cpu=samples,heap=sites,force=n,thread=y,verbose=n,file=%s</span>
          
</p>
<a name="Debugging"></a>
<h4>Debugging</h4>
<p>The MapReduce framework provides a facility to run user-provided 
          scripts for debugging. When a MapReduce task fails, a user can run 
          a debug script, to process task logs for example. The script is 
          given access to the task's stdout and stderr outputs, syslog and 
          jobconf. The output from the debug script's stdout and stderr is 
          displayed on the console diagnostics and also as part of the 
          job UI. </p>
<p> In the following sections we discuss how to submit a debug script
          with a job. The script file needs to be distributed and submitted to 
          the framework.</p>
<a name="How+to+distribute+the+script+file%3A"></a>
<h5> How to distribute the script file: </h5>
<p>
          The user needs to use  
          <a href="mapred_tutorial.html#DistributedCache">DistributedCache</a>
          to <em>distribute</em> and <em>symlink</em> the script file.</p>
<a name="How+to+submit+the+script%3A"></a>
<h5> How to submit the script: </h5>
<p> A quick way to submit the debug script is to set values for the 
          properties <span class="codefrag">mapreduce.map.debug.script</span> and 
          <span class="codefrag">mapreduce.reduce.debug.script</span>, for debugging map and 
          reduce tasks respectively. These properties can also be set by using APIs 
          <span class="codefrag">Job.getConfiguration().set(Job.MAP_DEBUG_SCRIPT, String)</span>
          and <span class="codefrag">Job.getConfiguration().set(Job.REDUCE_DEBUG_SCRIPT,
          String)</span>. In streaming mode, a debug 
          script can be submitted with the command-line options 
          <span class="codefrag">-mapdebug</span> and <span class="codefrag">-reducedebug</span>, for debugging 
          map and reduce tasks respectively.</p>
<p>The arguments to the script are the task's stdout, stderr, 
          syslog and jobconf files. The debug command, run on the node where
          the MapReduce task failed, is: <br>
          
<span class="codefrag"> $script $stdout $stderr $syslog $jobconf </span> 
</p>
<p> Pipes programs have the c++ program name as a fifth argument
          for the command. Thus for the pipes programs the command is <br> 
          
<span class="codefrag">$script $stdout $stderr $syslog $jobconf $program </span>  
          
</p>
<a name="Default+Behavior%3A"></a>
<h5> Default Behavior: </h5>
<p> For pipes, a default script is run to process core dumps under
          gdb, prints stack trace and gives info about running threads. </p>
<a name="JobControl"></a>
<h4>JobControl</h4>
<p>
<a href="api/org/apache/hadoop/mapred/jobcontrol/package-summary.html">
          JobControl</a> is a utility which encapsulates a set of MapReduce jobs
          and their dependencies.</p>
<a name="Data+Compression"></a>
<h4>Data Compression</h4>
<p>Hadoop MapReduce provides facilities for the application-writer to
          specify compression for both intermediate map-outputs and the
          job-outputs i.e. output of the reduces. It also comes bundled with
          <a href="api/org/apache/hadoop/io/compress/CompressionCodec.html">
          CompressionCodec</a> implementation for the 
          <a href="http://www.zlib.net/">zlib</a> compression 
          algorithm. The <a href="http://www.gzip.org/">gzip</a> file format is also
          supported.</p>
<p>Hadoop also provides native implementations of the above compression
          codecs for reasons of both performance (zlib) and non-availability of
          Java libraries. For more information see the
          <a href="http://hadoop.apache.org/common/docs/current/native_libraries.html">Native Libraries Guide</a>.</p>
<a name="Intermediate+Outputs"></a>
<h5>Intermediate Outputs</h5>
<p>Applications can control compression of intermediate map-outputs
            via the <span class="codefrag">Job.getConfiguration().setBoolean(Job.MAP_OUTPUT_COMPRESS, bool)</span>
            api and the <span class="codefrag">CompressionCodec</span> to be used via the
            <span class="codefrag">Job.getConfiguration().setClass(Job.MAP_OUTPUT_COMPRESS_CODEC, Class,
            CompressionCodec.class)</span> api.</p>
<a name="Job+Outputs"></a>
<h5>Job Outputs</h5>
<p>Applications can control compression of job-outputs via the
            <a href="api/org/apache/hadoop/mapreduce/lib/output/FileOutputFormat.html#setCompressOutput(org.apache.hadoop.mapreduce.Job,%20boolean)">
            FileOutputFormat.setCompressOutput(Job, boolean)</a> api and the 
            <span class="codefrag">CompressionCodec</span> to be used can be specified via the
            <a href="api/org/apache/hadoop/mapreduce/lib/output/FileOutputFormat.html#setOutputCompressorClass(org.apache.hadoop.mapreduce.Job,%20java.lang.Class)">
            FileOutputFormat.setOutputCompressorClass(Job, Class)</a> api.</p>
<p>If the job outputs are to be stored in the 
            <a href="api/org/apache/hadoop/mapreduce/lib/output/SequenceFileOutputFormat.html">
            SequenceFileOutputFormat</a>, the required
            <span class="codefrag">SequenceFile.CompressionType</span> (i.e. <span class="codefrag">RECORD</span> / 
            <span class="codefrag">BLOCK</span> - defaults to <span class="codefrag">RECORD</span>) can be 
            specified via the 
            <a href="api/org/apache/hadoop/mapreduce/lib/output/SequenceFileOutputFormat.html#setOutputCompressionType(org.apache.hadoop.mapreduce.Job,%20org.apache.hadoop.io.SequenceFile.CompressionType)">
            SequenceFileOutputFormat.setOutputCompressionType(Job, 
            SequenceFile.CompressionType)</a> api.</p>
<a name="Skipping+Bad+Records"></a>
<h4>Skipping Bad Records</h4>
<p>Hadoop provides an option where a certain set of bad input 
          records can be skipped when processing map inputs. Applications 
          can control this feature through the  
          <a href="api/org/apache/hadoop/mapred/SkipBadRecords.html">
          SkipBadRecords</a> class.</p>
<p>This feature can be used when map tasks crash deterministically 
          on certain input. This usually happens due to bugs in the 
          map function. Usually, the user would have to fix these bugs. 
          This is, however, not possible sometimes. The bug may be in third 
          party libraries, for example, for which the source code is not 
          available. In such cases, the task never completes successfully even
          after multiple attempts, and the job fails. With this feature, only 
          a small portion of data surrounding the 
          bad records is lost, which may be acceptable for some applications 
          (those performing statistical analysis on very large data, for 
          example). </p>
<p>By default this feature is disabled. For enabling it, 
          refer to <a href="api/org/apache/hadoop/mapred/SkipBadRecords.html#setMapperMaxSkipRecords(org.apache.hadoop.conf.Configuration, long)">
          SkipBadRecords.setMapperMaxSkipRecords(Configuration, long)</a> and 
          <a href="api/org/apache/hadoop/mapred/SkipBadRecords.html#setReducerMaxSkipGroups(org.apache.hadoop.conf.Configuration, long)">
          SkipBadRecords.setReducerMaxSkipGroups(Configuration, long)</a>.
          </p>
<p>With this feature enabled, the framework gets into 'skipping 
          mode' after a certain number of map failures. For more details, 
          see <a href="api/org/apache/hadoop/mapred/SkipBadRecords.html#setAttemptsToStartSkipping(org.apache.hadoop.conf.Configuration, int)">
          SkipBadRecords.setAttemptsToStartSkipping(Configuration, int)</a>. 
          In 'skipping mode', map tasks maintain the range of records being 
          processed. To do this, the framework relies on the processed record 
          counter. See <a href="api/org/apache/hadoop/mapred/SkipBadRecords.html#COUNTER_MAP_PROCESSED_RECORDS">
          SkipBadRecords.COUNTER_MAP_PROCESSED_RECORDS</a> and 
          <a href="api/org/apache/hadoop/mapred/SkipBadRecords.html#COUNTER_REDUCE_PROCESSED_GROUPS">
          SkipBadRecords.COUNTER_REDUCE_PROCESSED_GROUPS</a>. 
          This counter enables the framework to know how many records have 
          been processed successfully, and hence, what record range caused 
          a task to crash. On further attempts, this range of records is 
          skipped.</p>
<p>The number of records skipped depends on how frequently the 
          processed record counter is incremented by the application. 
          It is recommended that this counter be incremented after every 
          record is processed. This may not be possible in some applications 
          that typically batch their processing. In such cases, the framework 
          may skip additional records surrounding the bad record. Users can 
          control the number of skipped records through 
          <a href="api/org/apache/hadoop/mapred/SkipBadRecords.html#setMapperMaxSkipRecords(org.apache.hadoop.conf.Configuration, long)">
          SkipBadRecords.setMapperMaxSkipRecords(Configuration, long)</a> and 
          <a href="api/org/apache/hadoop/mapred/SkipBadRecords.html#setReducerMaxSkipGroups(org.apache.hadoop.conf.Configuration, long)">
          SkipBadRecords.setReducerMaxSkipGroups(Configuration, long)</a>. 
          The framework tries to narrow the range of skipped records using a 
          binary search-like approach. The skipped range is divided into two 
          halves and only one half gets executed. On subsequent 
          failures, the framework figures out which half contains 
          bad records. A task will be re-executed till the
          acceptable skipped value is met or all task attempts are exhausted.
          To increase the number of task attempts, use
          <a href="api/org/apache/hadoop/mapreduce/Job.html#setMaxMapAttempts(int)">
          Job.setMaxMapAttempts(int)</a> and 
          <a href="api/org/apache/hadoop/mapreduce/Job.html#setMaxReduceAttempts(int)">
          Job.setMaxReduceAttempts(int)</a>.
          </p>
<p>Skipped records are written to HDFS in the sequence file 
          format, for later analysis. The location can be changed through 
          <a href="api/org/apache/hadoop/mapred/SkipBadRecords.html#setSkipOutputPath(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.fs.Path)">
          SkipBadRecords.setSkipOutputPath(conf, Path)</a>.
          </p>
</div>

    
<a name="Example%3A+WordCount+v2.0"></a>
<h2 class="h3">Example: WordCount v2.0</h2>
<div class="section">
<p>Here is a more complete <span class="codefrag">WordCount</span> which uses many of the
      features provided by the MapReduce framework we discussed so far.</p>
<p>This example needs the HDFS to be up and running, especially for the 
      <span class="codefrag">DistributedCache</span>-related features. Hence it only works with a 
      pseudo-distributed (<a href="http://hadoop.apache.org/common/docs/current/single_node_setup.html">Single Node Setup</a>) 
     or fully-distributed (<a href="http://hadoop.apache.org/common/docs/current/cluster_setup.html#Fully-Distributed+Operation">Cluster Setup</a>) 
      Hadoop installation.</p>
<a name="Source+Code-N1128C"></a>
<h3 class="h4">Source Code</h3>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
          
<tr>
            
<th colspan="1" rowspan="1"></th>
            <th colspan="1" rowspan="1">WordCount2.java</th>
          
</tr>

<tr>
<td colspan="1" rowspan="1">1.</td><td colspan="1" rowspan="1"><span class="codefrag">package&nbsp;org.myorg;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">2.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">3.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;java.io.*;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">4.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;java.util.*;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">5.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">6.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;org.apache.hadoop.fs.Path;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">7.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;org.apache.hadoop.filecache.DistributedCache;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">8.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;org.apache.hadoop.conf.*;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">9.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;org.apache.hadoop.io.*;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">10.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;org.apache.hadoop.mapreduce.*;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">11.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;org.apache.hadoop.mapreduce.lib.input.*;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">12.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;org.apache.hadoop.mapreduce.lib.output.*;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">13.</td><td colspan="1" rowspan="1"><span class="codefrag">import&nbsp;org.apache.hadoop.util.*;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">14.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">15.</td><td colspan="1" rowspan="1"><span class="codefrag">public&nbsp;class&nbsp;WordCount2&nbsp;extends&nbsp;Configured&nbsp;implements&nbsp;Tool&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">16.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">17.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;class&nbsp;Map
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">18.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extends&nbsp;Mapper&lt;LongWritable,&nbsp;Text,&nbsp;Text,&nbsp;IntWritable&gt;&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">19.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">20.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;enum&nbsp;Counters&nbsp;{&nbsp;INPUT_WORDS&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">21.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">22.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;static&nbsp;IntWritable&nbsp;one&nbsp;=&nbsp;new&nbsp;IntWritable(1);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">23.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Text&nbsp;word&nbsp;=&nbsp;new&nbsp;Text();
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">24.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">25.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;boolean&nbsp;caseSensitive&nbsp;=&nbsp;true;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">26.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Set&lt;String&gt;&nbsp;patternsToSkip&nbsp;=&nbsp;new&nbsp;HashSet&lt;String&gt;();
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">27.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">28.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;long&nbsp;numRecords&nbsp;=&nbsp;0;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">29.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;inputFile;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">30.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">31.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setup(Context&nbsp;context)&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">32.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Configuration&nbsp;conf&nbsp;=&nbsp;context.getConfiguration();
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">33.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;caseSensitive&nbsp;=&nbsp;conf.getBoolean("wordcount.case.sensitive",&nbsp;true);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">34.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputFile&nbsp;=&nbsp;conf.get("mapreduce.map.input.file");
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">35.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">36.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(conf.getBoolean("wordcount.skip.patterns",&nbsp;false))&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">37.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Path[]&nbsp;patternsFiles&nbsp;=&nbsp;new&nbsp;Path[0];
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">38.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">39.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patternsFiles&nbsp;=&nbsp;DistributedCache.getLocalCacheFiles(conf);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">40.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(IOException&nbsp;ioe)&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">41.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println("Caught&nbsp;exception&nbsp;while&nbsp;getting&nbsp;cached&nbsp;files:&nbsp;"
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">42.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;StringUtils.stringifyException(ioe));
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">43.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">44.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Path&nbsp;patternsFile&nbsp;:&nbsp;patternsFiles)&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">45.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parseSkipFile(patternsFile);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">46.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">47.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">48.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">49.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">50.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;parseSkipFile(Path&nbsp;patternsFile)&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">51.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">52.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedReader&nbsp;fis&nbsp;=&nbsp;new&nbsp;BufferedReader(new&nbsp;FileReader(
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">53.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patternsFile.toString()));
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">54.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;pattern&nbsp;=&nbsp;null;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">55.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;((pattern&nbsp;=&nbsp;fis.readLine())&nbsp;!=&nbsp;null)&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">56.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patternsToSkip.add(pattern);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">57.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">58.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(IOException&nbsp;ioe)&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">59.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println("Caught&nbsp;exception&nbsp;while&nbsp;parsing&nbsp;the&nbsp;cached&nbsp;file&nbsp;'"
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">60.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;patternsFile&nbsp;+&nbsp;"'&nbsp;:&nbsp;"&nbsp;+&nbsp;StringUtils.stringifyException(ioe));
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">61.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">62.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">63.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">64.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;map(LongWritable&nbsp;key,&nbsp;Text&nbsp;value,&nbsp;Context&nbsp;context)
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">65.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;IOException,&nbsp;InterruptedException&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">66.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;line&nbsp;=&nbsp;(caseSensitive)&nbsp;?
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">67.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value.toString()&nbsp;:&nbsp;value.toString().toLowerCase();
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">68.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">69.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(String&nbsp;pattern&nbsp;:&nbsp;patternsToSkip)&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">70.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;=&nbsp;line.replaceAll(pattern,&nbsp;"");
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">71.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">72.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">73.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer&nbsp;tokenizer&nbsp;=&nbsp;new&nbsp;StringTokenizer(line);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">74.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(tokenizer.hasMoreTokens())&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">75.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;word.set(tokenizer.nextToken());
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">76.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context.write(word,&nbsp;one);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">77.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context.getCounter(Counters.INPUT_WORDS).increment(1);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">78.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">79.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">80.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((++numRecords&nbsp;%&nbsp;100)&nbsp;==&nbsp;0)&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">81.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context.setStatus("Finished&nbsp;processing&nbsp;"&nbsp;+&nbsp;numRecords
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">82.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;"&nbsp;records&nbsp;"&nbsp;+&nbsp;"from&nbsp;the&nbsp;input&nbsp;file:&nbsp;"&nbsp;+&nbsp;inputFile);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">83.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">84.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">85.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">86.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">87.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;class&nbsp;Reduce
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">88.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extends&nbsp;Reducer&lt;Text,&nbsp;IntWritable,&nbsp;Text,&nbsp;IntWritable&gt;&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">89.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;reduce(Text&nbsp;key,&nbsp;Iterable&lt;IntWritable&gt;&nbsp;values,
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">90.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Context&nbsp;context)&nbsp;throws&nbsp;IOException,&nbsp;InterruptedException&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">91.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">92.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;sum&nbsp;=&nbsp;0;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">93.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(IntWritable&nbsp;val&nbsp;:&nbsp;values)&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">94.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;val.get();
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">95.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">96.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context.write(key,&nbsp;new&nbsp;IntWritable(sum));
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">97.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">98.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">99.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">100.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;run(String[]&nbsp;args)&nbsp;throws&nbsp;Exception&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">101.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Job&nbsp;job&nbsp;=&nbsp;new&nbsp;Job(getConf());
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">102.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.setJarByClass(WordCount2.class);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">103.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.setJobName("wordcount2.0");
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">104.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">105.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.setOutputKeyClass(Text.class);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">106.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.setOutputValueClass(IntWritable.class);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">107.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">108.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.setMapperClass(Map.class);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">109.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.setCombinerClass(Reduce.class);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">110.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.setReducerClass(Reduce.class);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">111.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">112.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Note&nbsp;that&nbsp;these&nbsp;are&nbsp;the&nbsp;default.
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">113.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.setInputFormatClass(TextInputFormat.class);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">114.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.setOutputFormatClass(TextOutputFormat.class);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">115.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">116.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;String&gt;&nbsp;other_args&nbsp;=&nbsp;new&nbsp;ArrayList&lt;String&gt;();
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">117.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i=0;&nbsp;i&nbsp;&lt;&nbsp;args.length;&nbsp;++i)&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">118.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;("-skip".equals(args[i]))&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">119.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DistributedCache.addCacheFile(new&nbsp;Path(args[++i]).toUri(),
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">120.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.getConfiguration());
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">121.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job.getConfiguration().setBoolean("wordcount.skip.patterns",&nbsp;true);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">122.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">123.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other_args.add(args[i]);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">124.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">125.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">126.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">127.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileInputFormat.setInputPaths(job,&nbsp;new&nbsp;Path(other_args.get(0)));
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">128.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileOutputFormat.setOutputPath(job,&nbsp;new&nbsp;Path(other_args.get(1)));
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">129.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">130.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;success&nbsp;=&nbsp;job.waitForCompletion(true);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">131.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;success&nbsp;?&nbsp;0&nbsp;:&nbsp;1;
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">132.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">133.</td><td colspan="1" rowspan="1"><span class="codefrag">
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">134.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;Exception&nbsp;{
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">135.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;res&nbsp;=&nbsp;ToolRunner.run(new&nbsp;Configuration(),&nbsp;new&nbsp;WordCount2(),&nbsp;args);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">136.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(res);
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">137.</td><td colspan="1" rowspan="1"><span class="codefrag">&nbsp;&nbsp;&nbsp;}
</span></td>
</tr>

<tr>
<td colspan="1" rowspan="1">138.</td><td colspan="1" rowspan="1"><span class="codefrag">}
</span></td>
</tr>
        
</table>
<a name="Sample+Runs"></a>
<h3 class="h4">Sample Runs</h3>
<p>Sample text-files as input:</p>
<p>
          
<span class="codefrag">$ bin/hadoop fs -ls /user/joe/wordcount/input/</span>
<br>
          
<span class="codefrag">/user/joe/wordcount/input/file01</span>
<br>
          
<span class="codefrag">/user/joe/wordcount/input/file02</span>
<br>
          
<br>
          
<span class="codefrag">$ bin/hadoop fs -cat /user/joe/wordcount/input/file01</span>
<br>
          
<span class="codefrag">Hello World, Bye World!</span>
<br>
          
<br>
          
<span class="codefrag">$ bin/hadoop fs -cat /user/joe/wordcount/input/file02</span>
<br>
          
<span class="codefrag">Hello Hadoop, Goodbye to hadoop.</span>
        
</p>
<p>Run the application:</p>
<p>
          
<span class="codefrag">
            $ bin/hadoop jar /user/joe/wordcount.jar org.myorg.WordCount2
              /user/joe/wordcount/input /user/joe/wordcount/output 
          </span>
        
</p>
<p>Output:</p>
<p>
          
<span class="codefrag">
            $ bin/hadoop fs -cat /user/joe/wordcount/output/part-r-00000
          </span>
          
<br>
          
<span class="codefrag">Bye    1</span>
<br>
          
<span class="codefrag">Goodbye    1</span>
<br>
          
<span class="codefrag">Hadoop,    1</span>
<br>
          
<span class="codefrag">Hello    2</span>
<br>
          
<span class="codefrag">World!    1</span>
<br>
          
<span class="codefrag">World,    1</span>
<br>
          
<span class="codefrag">hadoop.    1</span>
<br>
          
<span class="codefrag">to    1</span>
<br>
        
</p>
<p>Notice that the inputs differ from the first version we looked at, 
        and how they affect the outputs.</p>
<p>Now, lets plug-in a pattern-file which lists the word-patterns to be 
        ignored, via the <span class="codefrag">DistributedCache</span>.</p>
<p>
          
<span class="codefrag">$ hadoop fs -cat /user/joe/wordcount/patterns.txt</span>
<br>
          
<span class="codefrag">\.</span>
<br>
          
<span class="codefrag">\,</span>
<br>
          
<span class="codefrag">\!</span>
<br>
          
<span class="codefrag">to</span>
<br>
        
</p>
<p>Run it again, this time with more options:</p>
<p>
          
<span class="codefrag">
            $ bin/hadoop jar /user/joe/wordcount.jar org.myorg.WordCount2
              -Dwordcount.case.sensitive=true /user/joe/wordcount/input 
              /user/joe/wordcount/output -skip /user/joe/wordcount/patterns.txt
          </span>
        
</p>
<p>As expected, the output:</p>
<p>
          
<span class="codefrag">
            $ bin/hadoop fs -cat /user/joe/wordcount/output/part-r-00000
          </span>
          
<br>
          
<span class="codefrag">Bye    1</span>
<br>
          
<span class="codefrag">Goodbye    1</span>
<br>
          
<span class="codefrag">Hadoop    1</span>
<br>
          
<span class="codefrag">Hello    2</span>
<br>
          
<span class="codefrag">World    2</span>
<br>
          
<span class="codefrag">hadoop    1</span>
<br>
        
</p>
<p>Run it once more, this time switch-off case-sensitivity:</p>
<p>
          
<span class="codefrag">
            $ bin/hadoop jar /user/joe/wordcount.jar org.myorg.WordCount2
              -Dwordcount.case.sensitive=false /user/joe/wordcount/input 
              /user/joe/wordcount/output -skip /user/joe/wordcount/patterns.txt
          </span>
        
</p>
<p>Sure enough, the output:</p>
<p>
          
<span class="codefrag">
            $ bin/hadoop fs -cat /user/joe/wordcount/output/part-r-00000
          </span>
          
<br>
          
<span class="codefrag">bye    1</span>
<br>
          
<span class="codefrag">goodbye    1</span>
<br>
          
<span class="codefrag">hadoop    2</span>
<br>
          
<span class="codefrag">hello    2</span>
<br>
          
<span class="codefrag">world    2</span>
<br>
        
</p>
<a name="Highlights"></a>
<h3 class="h4">Highlights</h3>
<p>The second version of <span class="codefrag">WordCount</span> improves upon the 
        previous one by using some features offered by the MapReduce framework:
        </p>
<ul>
          
<li>
            Demonstrates how applications can access configuration parameters
            in the <span class="codefrag">setup</span> method of the <span class="codefrag">Mapper</span> (and
            <span class="codefrag">Reducer</span>) implementations (lines 31-48).
          </li>
          
<li>
            Demonstrates how the <span class="codefrag">DistributedCache</span> can be used to 
            distribute read-only data needed by the jobs. Here it allows the user 
            to specify word-patterns to skip while counting (line 119).
          </li>
          
<li>
            Demonstrates the utility of the <span class="codefrag">Tool</span> interface and the
            <span class="codefrag">GenericOptionsParser</span> to handle generic Hadoop 
            command-line options (line 135).
          </li>
          
<li>
            Demonstrates how applications can use <span class="codefrag">Counters</span> (line 77)
            and how they can set application-specific status information via 
            the <span class="codefrag">Context</span> instance passed to the <span class="codefrag">map</span> (and
            <span class="codefrag">reduce</span>) method (line 81).
          </li>
        
</ul>
</div>

    
<p>
      
<em>Java and JNI are trademarks or registered trademarks of 
      Sun Microsystems, Inc. in the United States and other countries.</em>
    
</p>
    
  
</div>
<!--+
    |end content
    +-->
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<!--+
    |start bottomstrip
    +-->
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("Last Published: " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2009 <a href="http://www.apache.org/licenses/">The Apache Software Foundation.</a>
</div>
<!--+
    |end bottomstrip
    +-->
</div>
</body>
</html>
